{"ast":null,"code":"\"use strict\";\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\n\nconst bson_1 = require(\"./bson\");\n\nconst metrics_1 = require(\"./cmap/metrics\");\n\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\n\nconst constants_1 = require(\"./constants\");\n\nconst error_1 = require(\"./error\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst run_command_1 = require(\"./operations/run_command\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst transactions_1 = require(\"./transactions\");\n\nconst utils_1 = require(\"./utils\");\n\nconst minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    const error = new error_1.MongoExpiredSessionError();\n\n    if (typeof callback === 'function') {\n      callback(error);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n/** @internal */\n\n\nconst kServerSession = Symbol('serverSession');\n/** @internal */\n\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\n\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\n\nconst kPinnedConnection = Symbol('pinnedConnection');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\n\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a client session.\n   * @internal\n   * @param topology - The current client's topology (Internal Class)\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(topology, sessionPool, options, clientOptions) {\n    super();\n    /** @internal */\n\n    this[_a] = false;\n\n    if (topology == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options !== null && options !== void 0 ? options : {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this[kServerSession] = undefined;\n    this.supports = {\n      causalConsistency: options.snapshot !== true && options.causalConsistency !== false\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n\n\n  get id() {\n    var _b;\n\n    return (_b = this.serverSession) === null || _b === void 0 ? void 0 : _b.id;\n  }\n\n  get serverSession() {\n    if (this[kServerSession] == null) {\n      this[kServerSession] = this.sessionPool.acquire();\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    return this[kServerSession];\n  }\n  /** Whether or not this session is configured for snapshot reads */\n\n\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced() {\n    return this.topology.description.type === common_1.TopologyType.LoadBalanced;\n  }\n  /** @internal */\n\n\n  get pinnedConnection() {\n    return this[kPinnedConnection];\n  }\n  /** @internal */\n\n\n  pin(conn) {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n  }\n  /** @internal */\n\n\n  unpin(options) {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned() {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n\n  endSession(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    const finalOptions = {\n      force: true,\n      ...options\n    };\n    return (0, utils_1.maybePromise)(callback, done => {\n      if (this.hasEnded) {\n        maybeClearPinnedConnection(this, finalOptions);\n        return done();\n      }\n\n      const completeEndSession = () => {\n        maybeClearPinnedConnection(this, finalOptions); // release the server session back to the pool\n\n        this.sessionPool.release(this.serverSession);\n        this[kServerSession] = undefined; // mark the session as ended, and emit a signal\n\n        this.hasEnded = true;\n        this.emit('ended', this); // spec indicates that we should ignore all errors for `endSessions`\n\n        done();\n      };\n\n      if (this.serverSession && this.inTransaction()) {\n        this.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n        return;\n      }\n\n      completeEndSession();\n    });\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n\n\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n\n\n  advanceClusterTime(clusterTime) {\n    var _b, _c;\n\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n    }\n\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n    }\n\n    if (!clusterTime.signature || ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'number' && ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long' // apparently we decode the key to number?\n    ) {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n    }\n\n    (0, common_1._advanceClusterTime)(this, clusterTime);\n  }\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n\n\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n  /** Increment the transaction number on the internal ServerSession */\n\n\n  incrementTransactionNumber() {\n    if (this.serverSession) {\n      this.serverSession.txnNumber = typeof this.serverSession.txnNumber === 'number' ? this.serverSession.txnNumber + 1 : 0;\n    }\n  }\n  /** @returns whether this session is currently in a transaction or not */\n\n\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n\n\n  startTransaction(options) {\n    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoCompatibilityError('Transactions are not allowed with snapshot sessions');\n    }\n\n    assertAlive(this);\n\n    if (this.inTransaction()) {\n      throw new error_1.MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.topology);\n\n    if ((0, shared_1.isSharded)(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    } // increment txnNumber\n\n\n    this.incrementTransactionNumber(); // create transaction state\n\n    this.transaction = new transactions_1.Transaction({\n      readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,\n      writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,\n      readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,\n      maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n\n  commitTransaction(callback) {\n    return (0, utils_1.maybePromise)(callback, cb => endTransaction(this, 'commitTransaction', cb));\n  }\n\n  abortTransaction(callback) {\n    return (0, utils_1.maybePromise)(callback, cb => endTransaction(this, 'abortTransaction', cb));\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n\n\n  toBSON() {\n    throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * Runs a provided lambda within a transaction, retrying either the commit operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n   * return a Promise will result in undefined behavior.\n   *\n   * @param fn - A lambda to run within a transaction\n   * @param options - Optional settings for the transaction\n   */\n\n\n  withTransaction(fn, options) {\n    const startTime = (0, utils_1.now)();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n\n}\n\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\n\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\n\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel('TransientTransactionError')) {\n    return;\n  } // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n\n\n  if (conn) {\n    const servers = Array.from(session.topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {\n      loadBalancer.s.pool.checkIn(conn);\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n\n      if (options === null || options === void 0 ? void 0 : options.forceClear) {\n        loadBalancer.s.pool.clear(conn.serviceId);\n      }\n    }\n\n    session[kPinnedConnection] = undefined;\n  }\n}\n\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\n\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  session.startTransaction(options);\n  let promise;\n\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    session.abortTransaction();\n    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }, err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel('TransientTransactionError') && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel('UnknownTransactionCommitResult');\n      }\n\n      throw err;\n    }\n\n    if (session.transaction.isActive) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n\n    return maybeRetryOrThrow(err);\n  });\n}\n\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  } // handle any initial problematic cases\n\n\n  const txnState = session.transaction.state;\n\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  } // construct and send the command\n\n\n  const command = {\n    [commandName]: 1\n  }; // apply a writeConcern if specified\n\n  let writeConcern;\n\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n\n  function commandHandler(e, r) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      } // The spec indicates that we should ignore all errors on `abortTransaction`\n\n\n      return callback();\n    }\n\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n\n    if (e) {\n      if (e instanceof error_1.MongoNetworkError || e instanceof error_1.MongoWriteConcernError || (0, error_1.isRetryableError)(e) || isMaxTimeMSExpiredError(e)) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult'); // per txns spec, must unpin session in this case\n\n          session.unpin({\n            error: e\n          });\n        }\n      } else if (e.hasErrorLabel('TransientTransactionError')) {\n        session.unpin({\n          error: e\n        });\n      }\n    }\n\n    callback(e, r);\n  } // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n\n\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  } // send the command\n\n\n  (0, execute_operation_1.executeOperation)(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n    session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), (err, reply) => {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n\n    if (err && (0, error_1.isRetryableEndTransactionError)(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return (0, execute_operation_1.executeOperation)(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), (_err, _reply) => commandHandler(_err, _reply));\n    }\n\n    commandHandler(err, reply);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\n\n\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n\n\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n\n}\n\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\n\nclass ServerSessionPool {\n  constructor(topology) {\n    if (topology == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n  /** Ends all sessions in the session pool */\n\n\n  endAllPooledSessions(callback) {\n    if (this.sessions.length) {\n      this.topology.endSessions(this.sessions.map(session => session.id), () => {\n        this.sessions = [];\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n      });\n      return;\n    }\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n\n\n  acquire() {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes || 10;\n\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n\n      if (session && (this.topology.loadBalanced || !session.hasTimedOut(sessionTimeoutMinutes))) {\n        return session;\n      }\n    }\n\n    return new ServerSession();\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n\n\n  release(session) {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n    if (this.topology.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      } // otherwise, readd this session to the session pool\n\n\n      this.sessions.unshift(session);\n    }\n  }\n\n}\n\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n */\n\nfunction applySession(session, command, options) {\n  var _b; // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n\n\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  }\n\n  const serverSession = session.serverSession;\n\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  } // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n  // FIXME: NODE-2781, this check for write concern shouldn't be happening here, but instead during command construction\n\n\n  if (options && options.writeConcern && options.writeConcern.w === 0) {\n    if (session && session.explicit) {\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n\n    return;\n  } // mark the last use of this session, and apply the `lsid`\n\n\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id; // first apply non-transaction-specific sessions data\n\n  const inTransaction = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  const isRetryableWrite = (options === null || options === void 0 ? void 0 : options.willRetryWrite) || false;\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTransaction) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command, options)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n\n    return;\n  } // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || ((_b = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _b === void 0 ? void 0 : _b.readConcern);\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n}\n\nexports.applySession = applySession;\n\nfunction updateSessionFromResponse(session, document) {\n  var _b;\n\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;\n\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"mappings":"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","names":["minWireVersionForShardedTransactions","assertAlive","session","callback","serverSession","error","error_1","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","kPinnedConnection","ClientSession","mongo_types_1","constructor","topology","sessionPool","options","clientOptions","ServerSessionPool","snapshot","causalConsistency","hasEnded","undefined","supports","clusterTime","initialClusterTime","operationTime","explicit","owner","defaultTransactionOptions","Object","assign","transaction","transactions_1","id","_b","acquire","snapshotEnabled","loadBalanced","description","type","common_1","LoadBalanced","pinnedConnection","pin","conn","TypeError","emit","constants_1","inTransaction","metrics_1","TXN","CURSOR","unpin","maybeClearPinnedConnection","unpinServer","isPinned","endSession","finalOptions","force","done","completeEndSession","release","abortTransaction","err","advanceOperationTime","greaterThan","advanceClusterTime","_bsontype","signature","hash","keyId","_c","equals","buffer","incrementTransactionNumber","txnNumber","isActive","startTransaction","isCommitted","topologyMaxWireVersion","readConcern","_d","writeConcern","_e","_f","_g","readPreference","_h","_j","_k","maxCommitTimeMS","_l","transition","STARTING_TRANSACTION","commitTransaction","cb","endTransaction","toBSON","withTransaction","fn","startTime","attemptTransaction","exports","MAX_WITH_TRANSACTION_TIMEOUT","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","isUnknownTransactionCommitResult","isNonDeterministicWriteConcernError","codeName","has","isMaxTimeMSExpiredError","code","UnsatisfiableWriteConcern","UnknownReplWriteConcern","hasErrorLabel","servers","Array","from","s","values","loadBalancer","pool","checkIn","state","NO_TRANSACTION","forceClear","clear","serviceId","MaxTimeMSExpired","writeConcernError","attemptTransactionCommit","catch","USER_EXPLICIT_TXN_END_STATES","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","Promise","promise_provider_1","get","promise","reject","then","maybeRetryOrThrow","addErrorLabel","commandName","txnState","TRANSACTION_COMMITTED_EMPTY","command","w","wtimeout","maxTimeMS","commandHandler","e","r","recoveryToken","run_command_1","read_preference_1","primary","bypassPinningCheck","reply","_err","_reply","ServerSession","bson_1","SUBTYPE_UUID","lastUse","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","sessions","endAllPooledSessions","length","endSessions","map","logicalSessionTimeoutMinutes","shift","unshift","pooledSession","pop","applySession","lsid","isRetryableWrite","willRetryWrite","fromNumber","afterClusterTime","level","read_concern_1","atClusterTime","autocommit","TRANSACTION_IN_PROGRESS","updateSessionFromResponse","document","$clusterTime","_recoveryToken","cursor"],"sources":["/Users/santiago/Documents/tulipan1637/iot-sensor/node_modules/mongodb/src/sessions.ts"],"sourcesContent":["import { Binary, Document, Long, Timestamp } from './bson';\nimport type { CommandOptions, Connection } from './cmap/connection';\nimport { ConnectionPoolMetrics } from './cmap/metrics';\nimport { isSharded } from './cmap/wire_protocol/shared';\nimport { PINNED, UNPINNED } from './constants';\nimport type { AbstractCursor } from './cursor/abstract_cursor';\nimport {\n  AnyError,\n  isRetryableEndTransactionError,\n  isRetryableError,\n  MongoAPIError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoDriverError,\n  MongoError,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoWriteConcernError\n} from './error';\nimport type { MongoOptions } from './mongo_client';\nimport { TypedEventEmitter } from './mongo_types';\nimport { executeOperation } from './operations/execute_operation';\nimport { RunAdminCommandOperation } from './operations/run_command';\nimport { PromiseProvider } from './promise_provider';\nimport { ReadConcernLevel } from './read_concern';\nimport { ReadPreference } from './read_preference';\nimport { _advanceClusterTime, ClusterTime, TopologyType } from './sdam/common';\nimport type { Topology } from './sdam/topology';\nimport { isTransactionCommand, Transaction, TransactionOptions, TxnState } from './transactions';\nimport {\n  calculateDurationInMs,\n  Callback,\n  commandSupportsReadConcern,\n  isPromiseLike,\n  maxWireVersion,\n  maybePromise,\n  now,\n  uuidV4\n} from './utils';\nimport type { WriteConcern } from './write_concern';\n\nconst minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session: ClientSession, callback?: Callback): boolean {\n  if (session.serverSession == null) {\n    const error = new MongoExpiredSessionError();\n    if (typeof callback === 'function') {\n      callback(error);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n\n/** @public */\nexport interface ClientSessionOptions {\n  /** Whether causal consistency should be enabled on this session */\n  causalConsistency?: boolean;\n  /** Whether all read operations should be read from the same snapshot for this session (NOTE: not compatible with `causalConsistency=true`) */\n  snapshot?: boolean;\n  /** The default TransactionOptions to use for transactions started on this session. */\n  defaultTransactionOptions?: TransactionOptions;\n\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  /** @internal */\n  explicit?: boolean;\n  /** @internal */\n  initialClusterTime?: ClusterTime;\n}\n\n/** @public */\nexport type WithTransactionCallback<T = void> = (session: ClientSession) => Promise<T>;\n\n/** @public */\nexport type ClientSessionEvents = {\n  ended(session: ClientSession): void;\n};\n\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n\n/** @public */\nexport interface EndSessionOptions {\n  /**\n   * An optional error which caused the call to end this session\n   * @internal\n   */\n  error?: AnyError;\n  force?: boolean;\n  forceClear?: boolean;\n}\n\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nexport class ClientSession extends TypedEventEmitter<ClientSessionEvents> {\n  /** @internal */\n  topology: Topology;\n  /** @internal */\n  sessionPool: ServerSessionPool;\n  hasEnded: boolean;\n  clientOptions?: MongoOptions;\n  supports: { causalConsistency: boolean };\n  clusterTime?: ClusterTime;\n  operationTime?: Timestamp;\n  explicit: boolean;\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  defaultTransactionOptions: TransactionOptions;\n  transaction: Transaction;\n  /** @internal */\n  [kServerSession]?: ServerSession;\n  /** @internal */\n  [kSnapshotTime]?: Timestamp;\n  /** @internal */\n  [kSnapshotEnabled] = false;\n  /** @internal */\n  [kPinnedConnection]?: Connection;\n\n  /**\n   * Create a client session.\n   * @internal\n   * @param topology - The current client's topology (Internal Class)\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(\n    topology: Topology,\n    sessionPool: ServerSessionPool,\n    options: ClientSessionOptions,\n    clientOptions?: MongoOptions\n  ) {\n    super();\n\n    if (topology == null) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options ?? {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new MongoInvalidArgumentError(\n          'Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive'\n        );\n      }\n    }\n\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this[kServerSession] = undefined;\n\n    this.supports = {\n      causalConsistency: options.snapshot !== true && options.causalConsistency !== false\n    };\n\n    this.clusterTime = options.initialClusterTime;\n\n    this.operationTime = undefined;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new Transaction();\n  }\n\n  /** The server id associated with this session */\n  get id(): ServerSessionId | undefined {\n    return this.serverSession?.id;\n  }\n\n  get serverSession(): ServerSession {\n    if (this[kServerSession] == null) {\n      this[kServerSession] = this.sessionPool.acquire();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this[kServerSession]!;\n  }\n\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled(): boolean {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced(): boolean {\n    return this.topology.description.type === TopologyType.LoadBalanced;\n  }\n\n  /** @internal */\n  get pinnedConnection(): Connection | undefined {\n    return this[kPinnedConnection];\n  }\n\n  /** @internal */\n  pin(conn: Connection): void {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(\n      PINNED,\n      this.inTransaction() ? ConnectionPoolMetrics.TXN : ConnectionPoolMetrics.CURSOR\n    );\n  }\n\n  /** @internal */\n  unpin(options?: { force?: boolean; forceClear?: boolean; error?: AnyError }): void {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned(): boolean {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n\n  /**\n   * Ends this session on the server\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   * @param callback - Optional callback for completion of this operation\n   */\n  endSession(): Promise<void>;\n  endSession(callback: Callback<void>): void;\n  endSession(options: EndSessionOptions): Promise<void>;\n  endSession(options: EndSessionOptions, callback: Callback<void>): void;\n  endSession(\n    options?: EndSessionOptions | Callback<void>,\n    callback?: Callback<void>\n  ): void | Promise<void> {\n    if (typeof options === 'function') (callback = options), (options = {});\n    const finalOptions = { force: true, ...options };\n\n    return maybePromise(callback, done => {\n      if (this.hasEnded) {\n        maybeClearPinnedConnection(this, finalOptions);\n        return done();\n      }\n\n      const completeEndSession = () => {\n        maybeClearPinnedConnection(this, finalOptions);\n\n        // release the server session back to the pool\n        this.sessionPool.release(this.serverSession);\n        this[kServerSession] = undefined;\n\n        // mark the session as ended, and emit a signal\n        this.hasEnded = true;\n        this.emit('ended', this);\n\n        // spec indicates that we should ignore all errors for `endSessions`\n        done();\n      };\n\n      if (this.serverSession && this.inTransaction()) {\n        this.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n\n        return;\n      }\n\n      completeEndSession();\n    });\n  }\n\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime: Timestamp): void {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n  advanceClusterTime(clusterTime: ClusterTime): void {\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new MongoInvalidArgumentError('input cluster time must be an object');\n    }\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new MongoInvalidArgumentError(\n        'input cluster time \"clusterTime\" property must be a valid BSON Timestamp'\n      );\n    }\n    if (\n      !clusterTime.signature ||\n      clusterTime.signature.hash?._bsontype !== 'Binary' ||\n      (typeof clusterTime.signature.keyId !== 'number' &&\n        clusterTime.signature.keyId?._bsontype !== 'Long') // apparently we decode the key to number?\n    ) {\n      throw new MongoInvalidArgumentError(\n        'input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId'\n      );\n    }\n\n    _advanceClusterTime(this, clusterTime);\n  }\n\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session: ClientSession): boolean {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n\n  /** Increment the transaction number on the internal ServerSession */\n  incrementTransactionNumber(): void {\n    if (this.serverSession) {\n      this.serverSession.txnNumber =\n        typeof this.serverSession.txnNumber === 'number' ? this.serverSession.txnNumber + 1 : 0;\n    }\n  }\n\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction(): boolean {\n    return this.transaction.isActive;\n  }\n\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options?: TransactionOptions): void {\n    if (this[kSnapshotEnabled]) {\n      throw new MongoCompatibilityError('Transactions are not allowed with snapshot sessions');\n    }\n\n    assertAlive(this);\n    if (this.inTransaction()) {\n      throw new MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.topology);\n    if (\n      isSharded(this.topology) &&\n      topologyMaxWireVersion != null &&\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\n    ) {\n      throw new MongoCompatibilityError(\n        'Transactions are not supported on sharded clusters in MongoDB < 4.2.'\n      );\n    }\n\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new Transaction({\n      readConcern:\n        options?.readConcern ??\n        this.defaultTransactionOptions.readConcern ??\n        this.clientOptions?.readConcern,\n      writeConcern:\n        options?.writeConcern ??\n        this.defaultTransactionOptions.writeConcern ??\n        this.clientOptions?.writeConcern,\n      readPreference:\n        options?.readPreference ??\n        this.defaultTransactionOptions.readPreference ??\n        this.clientOptions?.readPreference,\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n    });\n\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n\n  /**\n   * Commits the currently active transaction in this session.\n   *\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  commitTransaction(): Promise<Document>;\n  commitTransaction(callback: Callback<Document>): void;\n  commitTransaction(callback?: Callback<Document>): Promise<Document> | void {\n    return maybePromise(callback, cb => endTransaction(this, 'commitTransaction', cb));\n  }\n\n  /**\n   * Aborts the currently active transaction in this session.\n   *\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n  abortTransaction(): Promise<Document>;\n  abortTransaction(callback: Callback<Document>): void;\n  abortTransaction(callback?: Callback<Document>): Promise<Document> | void {\n    return maybePromise(callback, cb => endTransaction(this, 'abortTransaction', cb));\n  }\n\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON(): never {\n    throw new MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n\n  /**\n   * Runs a provided lambda within a transaction, retrying either the commit operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n   * return a Promise will result in undefined behavior.\n   *\n   * @param fn - A lambda to run within a transaction\n   * @param options - Optional settings for the transaction\n   */\n  withTransaction<T = void>(\n    fn: WithTransactionCallback<T>,\n    options?: TransactionOptions\n  ): ReturnType<typeof fn> {\n    const startTime = now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\n\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n  'CannotSatisfyWriteConcern',\n  'UnknownReplWriteConcern',\n  'UnsatisfiableWriteConcern'\n]);\n\nfunction hasNotTimedOut(startTime: number, max: number) {\n  return calculateDurationInMs(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err: MongoError) {\n  const isNonDeterministicWriteConcernError =\n    err instanceof MongoServerError &&\n    err.codeName &&\n    NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n\n  return (\n    isMaxTimeMSExpiredError(err) ||\n    (!isNonDeterministicWriteConcernError &&\n      err.code !== MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n      err.code !== MONGODB_ERROR_CODES.UnknownReplWriteConcern)\n  );\n}\n\nexport function maybeClearPinnedConnection(\n  session: ClientSession,\n  options?: EndSessionOptions\n): void {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options?.error;\n\n  if (\n    session.inTransaction() &&\n    error &&\n    error instanceof MongoError &&\n    error.hasErrorLabel('TransientTransactionError')\n  ) {\n    return;\n  }\n\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn) {\n    const servers = Array.from(session.topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if (options?.error == null || options?.force) {\n      loadBalancer.s.pool.checkIn(conn);\n      conn.emit(\n        UNPINNED,\n        session.transaction.state !== TxnState.NO_TRANSACTION\n          ? ConnectionPoolMetrics.TXN\n          : ConnectionPoolMetrics.CURSOR\n      );\n\n      if (options?.forceClear) {\n        loadBalancer.s.pool.clear(conn.serviceId);\n      }\n    }\n\n    session[kPinnedConnection] = undefined;\n  }\n}\n\nfunction isMaxTimeMSExpiredError(err: MongoError) {\n  if (err == null || !(err instanceof MongoServerError)) {\n    return false;\n  }\n\n  return (\n    err.code === MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n    (err.writeConcernError && err.writeConcernError.code === MONGODB_ERROR_CODES.MaxTimeMSExpired)\n  );\n}\n\nfunction attemptTransactionCommit<T>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<T>,\n  options?: TransactionOptions\n): Promise<T> {\n  return session.commitTransaction().catch((err: MongoError) => {\n    if (\n      err instanceof MongoError &&\n      hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n      !isMaxTimeMSExpiredError(err)\n    ) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set<TxnState>([\n  TxnState.NO_TRANSACTION,\n  TxnState.TRANSACTION_COMMITTED,\n  TxnState.TRANSACTION_ABORTED\n]);\n\nfunction userExplicitlyEndedTransaction(session: ClientSession) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction<TSchema>(\n  session: ClientSession,\n  startTime: number,\n  fn: WithTransactionCallback<TSchema>,\n  options?: TransactionOptions\n): Promise<any> {\n  const Promise = PromiseProvider.get();\n  session.startTransaction(options);\n\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new MongoInvalidArgumentError(\n      'Function provided to `withTransaction` must return a Promise'\n    );\n  }\n\n  return promise.then(\n    () => {\n      if (userExplicitlyEndedTransaction(session)) {\n        return;\n      }\n\n      return attemptTransactionCommit(session, startTime, fn, options);\n    },\n    err => {\n      function maybeRetryOrThrow(err: MongoError): Promise<any> {\n        if (\n          err instanceof MongoError &&\n          err.hasErrorLabel('TransientTransactionError') &&\n          hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)\n        ) {\n          return attemptTransaction(session, startTime, fn, options);\n        }\n\n        if (isMaxTimeMSExpiredError(err)) {\n          err.addErrorLabel('UnknownTransactionCommitResult');\n        }\n\n        throw err;\n      }\n\n      if (session.transaction.isActive) {\n        return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n      }\n\n      return maybeRetryOrThrow(err);\n    }\n  );\n}\n\nfunction endTransaction(session: ClientSession, commandName: string, callback: Callback<Document>) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  }\n\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoTransactionError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (\n      txnState === TxnState.STARTING_TRANSACTION ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(\n        new MongoTransactionError('Cannot call commitTransaction after calling abortTransaction')\n      );\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (\n      txnState === TxnState.TRANSACTION_COMMITTED ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      callback(\n        new MongoTransactionError('Cannot call abortTransaction after calling commitTransaction')\n      );\n      return;\n    }\n  }\n\n  // construct and send the command\n  const command: Document = { [commandName]: 1 };\n\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = { w: session.clientOptions.writeConcern.w };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, { writeConcern });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n  }\n\n  function commandHandler(e?: MongoError, r?: Document) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, { force: false });\n      }\n\n      // The spec indicates that we should ignore all errors on `abortTransaction`\n      return callback();\n    }\n\n    session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n    if (e) {\n      if (\n        e instanceof MongoNetworkError ||\n        e instanceof MongoWriteConcernError ||\n        isRetryableError(e) ||\n        isMaxTimeMSExpiredError(e)\n      ) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult');\n\n          // per txns spec, must unpin session in this case\n          session.unpin({ error: e });\n        }\n      } else if (e.hasErrorLabel('TransientTransactionError')) {\n        session.unpin({ error: e });\n      }\n    }\n\n    callback(e, r);\n  }\n\n  // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n\n  // send the command\n  executeOperation(\n    session.topology,\n    new RunAdminCommandOperation(undefined, command, {\n      session,\n      readPreference: ReadPreference.primary,\n      bypassPinningCheck: true\n    }),\n    (err, reply) => {\n      if (command.abortTransaction) {\n        // always unpin on abort regardless of command outcome\n        session.unpin();\n      }\n\n      if (err && isRetryableEndTransactionError(err as MongoError)) {\n        // SPEC-1185: apply majority write concern when retrying commitTransaction\n        if (command.commitTransaction) {\n          // per txns spec, must unpin session in this case\n          session.unpin({ force: true });\n\n          command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n            w: 'majority'\n          });\n        }\n\n        return executeOperation(\n          session.topology,\n          new RunAdminCommandOperation(undefined, command, {\n            session,\n            readPreference: ReadPreference.primary,\n            bypassPinningCheck: true\n          }),\n          (_err, _reply) => commandHandler(_err as MongoError, _reply)\n        );\n      }\n\n      commandHandler(err as MongoError, reply);\n    }\n  );\n}\n\n/** @public */\nexport type ServerSessionId = { id: Binary };\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nexport class ServerSession {\n  id: ServerSessionId;\n  lastUse: number;\n  txnNumber: number;\n  isDirty: boolean;\n\n  /** @internal */\n  constructor() {\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes: number): boolean {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(\n      ((calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000\n    );\n\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n}\n\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nexport class ServerSessionPool {\n  topology: Topology;\n  sessions: ServerSession[];\n\n  constructor(topology: Topology) {\n    if (topology == null) {\n      throw new MongoRuntimeError('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n\n  /** Ends all sessions in the session pool */\n  endAllPooledSessions(callback?: Callback<void>): void {\n    if (this.sessions.length) {\n      this.topology.endSessions(\n        this.sessions.map((session: ServerSession) => session.id),\n        () => {\n          this.sessions = [];\n          if (typeof callback === 'function') {\n            callback();\n          }\n        }\n      );\n\n      return;\n    }\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire(): ServerSession {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes || 10;\n\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n      if (session && (this.topology.loadBalanced || !session.hasTimedOut(sessionTimeoutMinutes))) {\n        return session;\n      }\n    }\n\n    return new ServerSession();\n  }\n\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session: ServerSession): void {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n    if (this.topology.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\n\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n */\nexport function applySession(\n  session: ClientSession,\n  command: Document,\n  options?: CommandOptions\n): MongoDriverError | undefined {\n  // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n  if (session.hasEnded) {\n    return new MongoExpiredSessionError();\n  }\n\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new MongoRuntimeError('Unable to acquire server session');\n  }\n\n  // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n  // FIXME: NODE-2781, this check for write concern shouldn't be happening here, but instead during command construction\n  if (options && options.writeConcern && (options.writeConcern as WriteConcern).w === 0) {\n    if (session && session.explicit) {\n      return new MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id;\n\n  // first apply non-transaction-specific sessions data\n  const inTransaction = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = options?.willRetryWrite || false;\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    }\n\n    if (\n      session.supports.causalConsistency &&\n      session.operationTime &&\n      commandSupportsReadConcern(command, options)\n    ) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || { level: ReadConcernLevel.snapshot };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n      }\n    }\n\n    return;\n  }\n\n  // now attempt to apply transaction-specific sessions data\n\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n\n    const readConcern =\n      session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n  }\n}\n\nexport function updateSessionFromResponse(session: ClientSession, document: Document): void {\n  if (document.$clusterTime) {\n    _advanceClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}