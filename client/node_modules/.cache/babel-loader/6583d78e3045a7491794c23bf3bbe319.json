{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ListCollectionsCursor = exports.ListCollectionsOperation = void 0;\n\nconst CONSTANTS = require(\"../constants\");\n\nconst abstract_cursor_1 = require(\"../cursor/abstract_cursor\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_1 = require(\"./command\");\n\nconst execute_operation_1 = require(\"./execute_operation\");\n\nconst operation_1 = require(\"./operation\");\n\nconst LIST_COLLECTIONS_WIRE_VERSION = 3;\n/** @internal */\n\nclass ListCollectionsOperation extends command_1.CommandOperation {\n  constructor(db, filter, options) {\n    super(db, options);\n    this.options = options !== null && options !== void 0 ? options : {};\n    this.db = db;\n    this.filter = filter;\n    this.nameOnly = !!this.options.nameOnly;\n    this.authorizedCollections = !!this.options.authorizedCollections;\n\n    if (typeof this.options.batchSize === 'number') {\n      this.batchSize = this.options.batchSize;\n    }\n  }\n\n  execute(server, session, callback) {\n    if ((0, utils_1.maxWireVersion)(server) < LIST_COLLECTIONS_WIRE_VERSION) {\n      let filter = this.filter;\n      const databaseName = this.db.s.namespace.db; // If we have legacy mode and have not provided a full db name filter it\n\n      if (typeof filter.name === 'string' && !new RegExp(`^${databaseName}\\\\.`).test(filter.name)) {\n        filter = Object.assign({}, filter);\n        filter.name = this.db.s.namespace.withCollection(filter.name).toString();\n      } // No filter, filter by current database\n\n\n      if (filter == null) {\n        filter = {\n          name: `/${databaseName}/`\n        };\n      } // Rewrite the filter to use $and to filter out indexes\n\n\n      if (filter.name) {\n        filter = {\n          $and: [{\n            name: filter.name\n          }, {\n            name: /^((?!\\$).)*$/\n          }]\n        };\n      } else {\n        filter = {\n          name: /^((?!\\$).)*$/\n        };\n      }\n\n      const documentTransform = doc => {\n        const matching = `${databaseName}.`;\n        const index = doc.name.indexOf(matching); // Remove database name if available\n\n        if (doc.name && index === 0) {\n          doc.name = doc.name.substr(index + matching.length);\n        }\n\n        return doc;\n      };\n\n      server.query(new utils_1.MongoDBNamespace(databaseName, CONSTANTS.SYSTEM_NAMESPACE_COLLECTION), {\n        query: filter\n      }, {\n        batchSize: this.batchSize || 1000,\n        readPreference: this.readPreference\n      }, (err, result) => {\n        if (result && result.documents && Array.isArray(result.documents)) {\n          result.documents = result.documents.map(documentTransform);\n        }\n\n        callback(err, result);\n      });\n      return;\n    }\n\n    return super.executeCommand(server, session, this.generateCommand(), callback);\n  }\n  /* This is here for the purpose of unit testing the final command that gets sent. */\n\n\n  generateCommand() {\n    return {\n      listCollections: 1,\n      filter: this.filter,\n      cursor: this.batchSize ? {\n        batchSize: this.batchSize\n      } : {},\n      nameOnly: this.nameOnly,\n      authorizedCollections: this.authorizedCollections\n    };\n  }\n\n}\n\nexports.ListCollectionsOperation = ListCollectionsOperation;\n/** @public */\n\nclass ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(db, filter, options) {\n    super((0, utils_1.getTopology)(db), db.s.namespace, options);\n    this.parent = db;\n    this.filter = filter;\n    this.options = options;\n  }\n\n  clone() {\n    return new ListCollectionsCursor(this.parent, this.filter, { ...this.options,\n      ...this.cursorOptions\n    });\n  }\n  /** @internal */\n\n\n  _initialize(session, callback) {\n    const operation = new ListCollectionsOperation(this.parent, this.filter, { ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    (0, execute_operation_1.executeOperation)((0, utils_1.getTopology)(this.parent), operation, (err, response) => {\n      if (err || response == null) return callback(err); // TODO: NODE-2882\n\n      callback(undefined, {\n        server: operation.server,\n        session,\n        response\n      });\n    });\n  }\n\n}\n\nexports.ListCollectionsCursor = ListCollectionsCursor;\n(0, operation_1.defineAspects)(ListCollectionsOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);","map":{"version":3,"mappings":"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","names":["LIST_COLLECTIONS_WIRE_VERSION","ListCollectionsOperation","command_1","constructor","db","filter","options","nameOnly","authorizedCollections","batchSize","execute","server","session","callback","databaseName","s","namespace","name","RegExp","test","Object","assign","withCollection","toString","$and","documentTransform","doc","matching","index","indexOf","substr","length","query","utils_1","CONSTANTS","SYSTEM_NAMESPACE_COLLECTION","readPreference","err","result","documents","Array","isArray","map","executeCommand","generateCommand","listCollections","cursor","exports","ListCollectionsCursor","abstract_cursor_1","parent","clone","cursorOptions","_initialize","operation","response","undefined","operation_1","READ_OPERATION","RETRYABLE","CURSOR_CREATING"],"sources":["/Users/santiago/node_modules/mongodb/src/operations/list_collections.ts"],"sourcesContent":["import type { Binary, Document } from '../bson';\nimport * as CONSTANTS from '../constants';\nimport { AbstractCursor } from '../cursor/abstract_cursor';\nimport type { Db } from '../db';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { Callback, getTopology, maxWireVersion, MongoDBNamespace } from '../utils';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { executeOperation, ExecutionResult } from './execute_operation';\nimport { Aspect, defineAspects } from './operation';\n\nconst LIST_COLLECTIONS_WIRE_VERSION = 3;\n\n/** @public */\nexport interface ListCollectionsOptions extends CommandOperationOptions {\n  /** Since 4.0: If true, will only return the collection name in the response, and will omit additional info */\n  nameOnly?: boolean;\n  /** Since 4.0: If true and nameOnly is true, allows a user without the required privilege (i.e. listCollections action on the database) to run the command when access control is enforced. */\n  authorizedCollections?: boolean;\n  /** The batchSize for the returned command cursor or if pre 2.8 the systems batch collection */\n  batchSize?: number;\n}\n\n/** @internal */\nexport class ListCollectionsOperation extends CommandOperation<string[]> {\n  options: ListCollectionsOptions;\n  db: Db;\n  filter: Document;\n  nameOnly: boolean;\n  authorizedCollections: boolean;\n  batchSize?: number;\n\n  constructor(db: Db, filter: Document, options?: ListCollectionsOptions) {\n    super(db, options);\n\n    this.options = options ?? {};\n    this.db = db;\n    this.filter = filter;\n    this.nameOnly = !!this.options.nameOnly;\n    this.authorizedCollections = !!this.options.authorizedCollections;\n\n    if (typeof this.options.batchSize === 'number') {\n      this.batchSize = this.options.batchSize;\n    }\n  }\n\n  execute(server: Server, session: ClientSession, callback: Callback<string[]>): void {\n    if (maxWireVersion(server) < LIST_COLLECTIONS_WIRE_VERSION) {\n      let filter = this.filter;\n      const databaseName = this.db.s.namespace.db;\n\n      // If we have legacy mode and have not provided a full db name filter it\n      if (typeof filter.name === 'string' && !new RegExp(`^${databaseName}\\\\.`).test(filter.name)) {\n        filter = Object.assign({}, filter);\n        filter.name = this.db.s.namespace.withCollection(filter.name).toString();\n      }\n\n      // No filter, filter by current database\n      if (filter == null) {\n        filter = { name: `/${databaseName}/` };\n      }\n\n      // Rewrite the filter to use $and to filter out indexes\n      if (filter.name) {\n        filter = { $and: [{ name: filter.name }, { name: /^((?!\\$).)*$/ }] };\n      } else {\n        filter = { name: /^((?!\\$).)*$/ };\n      }\n\n      const documentTransform = (doc: Document) => {\n        const matching = `${databaseName}.`;\n        const index = doc.name.indexOf(matching);\n        // Remove database name if available\n        if (doc.name && index === 0) {\n          doc.name = doc.name.substr(index + matching.length);\n        }\n\n        return doc;\n      };\n\n      server.query(\n        new MongoDBNamespace(databaseName, CONSTANTS.SYSTEM_NAMESPACE_COLLECTION),\n        { query: filter },\n        { batchSize: this.batchSize || 1000, readPreference: this.readPreference },\n        (err, result) => {\n          if (result && result.documents && Array.isArray(result.documents)) {\n            result.documents = result.documents.map(documentTransform);\n          }\n\n          callback(err, result);\n        }\n      );\n\n      return;\n    }\n\n    return super.executeCommand(server, session, this.generateCommand(), callback);\n  }\n\n  /* This is here for the purpose of unit testing the final command that gets sent. */\n  generateCommand(): Document {\n    return {\n      listCollections: 1,\n      filter: this.filter,\n      cursor: this.batchSize ? { batchSize: this.batchSize } : {},\n      nameOnly: this.nameOnly,\n      authorizedCollections: this.authorizedCollections\n    };\n  }\n}\n\n/** @public */\nexport interface CollectionInfo extends Document {\n  name: string;\n  type?: string;\n  options?: Document;\n  info?: {\n    readOnly?: false;\n    uuid?: Binary;\n  };\n  idIndex?: Document;\n}\n\n/** @public */\nexport class ListCollectionsCursor<\n  T extends Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo =\n    | Pick<CollectionInfo, 'name' | 'type'>\n    | CollectionInfo\n> extends AbstractCursor<T> {\n  parent: Db;\n  filter: Document;\n  options?: ListCollectionsOptions;\n\n  constructor(db: Db, filter: Document, options?: ListCollectionsOptions) {\n    super(getTopology(db), db.s.namespace, options);\n    this.parent = db;\n    this.filter = filter;\n    this.options = options;\n  }\n\n  clone(): ListCollectionsCursor<T> {\n    return new ListCollectionsCursor(this.parent, this.filter, {\n      ...this.options,\n      ...this.cursorOptions\n    });\n  }\n\n  /** @internal */\n  _initialize(session: ClientSession | undefined, callback: Callback<ExecutionResult>): void {\n    const operation = new ListCollectionsOperation(this.parent, this.filter, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n\n    executeOperation(getTopology(this.parent), operation, (err, response) => {\n      if (err || response == null) return callback(err);\n\n      // TODO: NODE-2882\n      callback(undefined, { server: operation.server, session, response });\n    });\n  }\n}\n\ndefineAspects(ListCollectionsOperation, [\n  Aspect.READ_OPERATION,\n  Aspect.RETRYABLE,\n  Aspect.CURSOR_CREATING\n]);\n"]},"metadata":{},"sourceType":"script"}