{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst server_selection_1 = require(\"../sdam/server_selection\");\n\nconst utils_1 = require(\"../utils\");\n\nconst operation_1 = require(\"./operation\");\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction executeOperation(topology, operation, callback) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  return (0, utils_1.maybePromise)(callback, cb => {\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, err => {\n        if (err) return cb(err);\n        executeOperation(topology, operation, cb);\n      });\n    } // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n\n\n    let session = operation.session;\n    let owner;\n\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = topology.startSession({\n          owner,\n          explicit: false\n        });\n      } else if (session.hasEnded) {\n        return cb(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return cb(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else if (session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return cb(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n    }\n\n    try {\n      executeWithServerSelection(topology, session, operation, (err, result) => {\n        if (session && session.owner && session.owner === owner) {\n          return session.endSession(err2 => cb(err2 || err, result));\n        }\n\n        cb(err, result);\n      });\n    } catch (e) {\n      if (session && session.owner && session.owner === owner) {\n        session.endSession();\n      }\n\n      throw e;\n    }\n  });\n}\n\nexports.executeOperation = executeOperation;\n\nfunction supportsRetryableReads(server) {\n  return (0, utils_1.maxWireVersion)(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, session, operation, callback) {\n  var _a;\n\n  const readPreference = operation.readPreference || read_preference_1.ReadPreference.primary;\n  const inTransaction = session && session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n\n  if (session && session.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  let selector;\n\n  if (operation.hasAspect(operation_1.Aspect.CURSOR_ITERATING)) {\n    // Get more operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)((_a = operation.server) === null || _a === void 0 ? void 0 : _a.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  const serverSelectionOptions = {\n    session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(undefined, result);\n    }\n\n    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const itShouldRetryWrite = shouldRetryWrite(err);\n\n    if (hasReadAspect && !(0, error_1.isRetryableError)(err) || hasWriteAspect && !itShouldRetryWrite) {\n      return callback(err);\n    }\n\n    if (hasWriteAspect && itShouldRetryWrite && err.code === MMAPv1_RETRY_WRITES_ERROR_CODE && err.errmsg.match(/Transaction numbers/)) {\n      callback(new error_1.MongoServerError({\n        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        originalError: err\n      }));\n      return;\n    } // select a new server, and attempt to retry the operation\n\n\n    topology.selectServer(selector, serverSelectionOptions, (e, server) => {\n      if (e || operation.hasAspect(operation_1.Aspect.READ_OPERATION) && !supportsRetryableReads(server) || operation.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !(0, utils_1.supportsRetryableWrites)(server)) {\n        callback(e);\n        return;\n      } // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n\n\n      if (err && err instanceof error_1.MongoNetworkError && server.loadBalanced && session && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n        session.unpin({\n          force: true,\n          forceClear: true\n        });\n      }\n\n      operation.execute(server, session, callback);\n    });\n  }\n\n  if (readPreference && !readPreference.equals(read_preference_1.ReadPreference.primary) && session && session.inTransaction()) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  } // select a server, and execute the operation against it\n\n\n  topology.selectServer(selector, serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n      const willRetryRead = topology.s.options.retryReads !== false && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;\n      const willRetryWrite = topology.s.options.retryWrites === true && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n\n      if (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n\n        operation.execute(server, session, callbackWithRetry);\n        return;\n      }\n    }\n\n    operation.execute(server, session, callback);\n  });\n}\n\nfunction shouldRetryWrite(err) {\n  return err instanceof error_1.MongoError && err.hasErrorLabel('RetryableWriteError');\n}","map":{"version":3,"mappings":"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","names":["MMAPv1_RETRY_WRITES_ERROR_CODE","error_1","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","executeOperation","topology","operation","callback","operation_1","cb","shouldCheckForSessionSupport","selectServer","read_preference_1","primaryPreferred","err","session","owner","hasSessionSupport","Symbol","startSession","explicit","hasEnded","snapshotEnabled","capabilities","supportsSnapshotReads","executeWithServerSelection","result","endSession","err2","e","exports","supportsRetryableReads","server","readPreference","primary","inTransaction","equals","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","selector","hasAspect","CURSOR_ITERATING","_a","description","trySecondaryWrite","commonWireVersion","serverSelectionOptions","callbackWithRetry","undefined","hasReadAspect","READ_OPERATION","hasWriteAspect","WRITE_OPERATION","itShouldRetryWrite","shouldRetryWrite","code","errmsg","match","message","originalError","loadBalanced","CURSOR_CREATING","force","forceClear","execute","RETRYABLE","willRetryRead","s","options","retryReads","canRetryRead","willRetryWrite","retryWrites","canRetryWrite","incrementTransactionNumber","hasErrorLabel"],"sources":["/Users/santiago/node_modules/mongodb/src/operations/execute_operation.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport {\n  isRetryableError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoExpiredSessionError,\n  MongoNetworkError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError\n} from '../error';\nimport { ReadPreference } from '../read_preference';\nimport type { Server } from '../sdam/server';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { Callback, maxWireVersion, maybePromise, supportsRetryableWrites } from '../utils';\nimport { AbstractOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> = TOperation extends AbstractOperation<infer K>\n  ? K\n  : never;\n\n/** @internal */\nexport interface ExecutionResult {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: Document;\n}\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param callback - The command result callback\n */\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(topology: Topology, operation: T): Promise<TResult>;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(topology: Topology, operation: T, callback: Callback<TResult>): void;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(topology: Topology, operation: T, callback?: Callback<TResult>): Promise<TResult> | void;\nexport function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(topology: Topology, operation: T, callback?: Callback<TResult>): Promise<TResult> | void {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  return maybePromise(callback, cb => {\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(ReadPreference.primaryPreferred, err => {\n        if (err) return cb(err);\n\n        executeOperation<T, TResult>(topology, operation, cb);\n      });\n    }\n\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session: ClientSession | undefined = operation.session;\n    let owner: symbol | undefined;\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = topology.startSession({ owner, explicit: false });\n      } else if (session.hasEnded) {\n        return cb(new MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return cb(new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else if (session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return cb(new MongoCompatibilityError('Current topology does not support sessions'));\n    }\n\n    try {\n      executeWithServerSelection(topology, session, operation, (err, result) => {\n        if (session && session.owner && session.owner === owner) {\n          return session.endSession(err2 => cb(err2 || err, result));\n        }\n\n        cb(err, result);\n      });\n    } catch (e) {\n      if (session && session.owner && session.owner === owner) {\n        session.endSession();\n      }\n\n      throw e;\n    }\n  });\n}\n\nfunction supportsRetryableReads(server: Server) {\n  return maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(\n  topology: Topology,\n  session: ClientSession,\n  operation: AbstractOperation,\n  callback: Callback\n) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = session && session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(\n      new MongoTransactionError(\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n      )\n    );\n\n    return;\n  }\n\n  if (\n    session &&\n    session.isPinned &&\n    session.transaction.isCommitted &&\n    !operation.bypassPinningCheck\n  ) {\n    session.unpin();\n  }\n\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.CURSOR_ITERATING)) {\n    // Get more operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  const serverSelectionOptions = { session };\n  function callbackWithRetry(err?: any, result?: any) {\n    if (err == null) {\n      return callback(undefined, result);\n    }\n\n    const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n    const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n    const itShouldRetryWrite = shouldRetryWrite(err);\n\n    if ((hasReadAspect && !isRetryableError(err)) || (hasWriteAspect && !itShouldRetryWrite)) {\n      return callback(err);\n    }\n\n    if (\n      hasWriteAspect &&\n      itShouldRetryWrite &&\n      err.code === MMAPv1_RETRY_WRITES_ERROR_CODE &&\n      err.errmsg.match(/Transaction numbers/)\n    ) {\n      callback(\n        new MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: err\n        })\n      );\n\n      return;\n    }\n\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(selector, serverSelectionOptions, (e?: any, server?: any) => {\n      if (\n        e ||\n        (operation.hasAspect(Aspect.READ_OPERATION) && !supportsRetryableReads(server)) ||\n        (operation.hasAspect(Aspect.WRITE_OPERATION) && !supportsRetryableWrites(server))\n      ) {\n        callback(e);\n        return;\n      }\n\n      // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n      if (\n        err &&\n        err instanceof MongoNetworkError &&\n        server.loadBalanced &&\n        session &&\n        session.isPinned &&\n        !session.inTransaction() &&\n        operation.hasAspect(Aspect.CURSOR_CREATING)\n      ) {\n        session.unpin({ force: true, forceClear: true });\n      }\n\n      operation.execute(server, session, callback);\n    });\n  }\n\n  if (\n    readPreference &&\n    !readPreference.equals(ReadPreference.primary) &&\n    session &&\n    session.inTransaction()\n  ) {\n    callback(\n      new MongoTransactionError(\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n      )\n    );\n\n    return;\n  }\n\n  // select a server, and execute the operation against it\n  topology.selectServer(selector, serverSelectionOptions, (err?: any, server?: any) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (session && operation.hasAspect(Aspect.RETRYABLE)) {\n      const willRetryRead =\n        topology.s.options.retryReads !== false &&\n        !inTransaction &&\n        supportsRetryableReads(server) &&\n        operation.canRetryRead;\n\n      const willRetryWrite =\n        topology.s.options.retryWrites === true &&\n        !inTransaction &&\n        supportsRetryableWrites(server) &&\n        operation.canRetryWrite;\n\n      const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n\n      if ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite)) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n\n        operation.execute(server, session, callbackWithRetry);\n        return;\n      }\n    }\n\n    operation.execute(server, session, callback);\n  });\n}\n\nfunction shouldRetryWrite(err: any) {\n  return err instanceof MongoError && err.hasErrorLabel('RetryableWriteError');\n}\n"]},"metadata":{},"sourceType":"script"}