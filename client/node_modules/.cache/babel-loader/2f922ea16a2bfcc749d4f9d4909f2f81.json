{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prepareDocs = exports.indexInformation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nfunction indexInformation(db, name, _optionsOrCallback, _callback) {\n  let options = _optionsOrCallback;\n  let callback = _callback;\n\n  if ('function' === typeof _optionsOrCallback) {\n    callback = _optionsOrCallback;\n    options = {};\n  } // If we specified full information\n\n\n  const full = options.full == null ? false : options.full; // Did the user destroy the topology\n\n  if ((0, utils_1.getTopology)(db).isDestroyed()) return callback(new error_1.MongoTopologyClosedError()); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    const info = {}; // Process all the indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (const name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray((err, indexes) => {\n    if (err) return callback(err);\n    if (!Array.isArray(indexes)) return callback(undefined, []);\n    if (full) return callback(undefined, indexes);\n    callback(undefined, processResults(indexes));\n  });\n}\n\nexports.indexInformation = indexInformation;\n\nfunction prepareDocs(coll, docs, options) {\n  var _a;\n\n  const forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : (_a = coll.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId; // no need to modify the docs if server sets the ObjectId\n\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n}\n\nexports.prepareDocs = prepareDocs;","map":{"version":3,"mappings":";;;;;;;AAGA;;AAGA;;AAqBA,SAAgBA,gBAAhB,CACEC,EADF,EAEEC,IAFF,EAGEC,kBAHF,EAIEC,SAJF,EAIsB;AAEpB,MAAIC,OAAO,GAAGF,kBAAd;AACA,MAAIG,QAAQ,GAAGF,SAAf;;AACA,MAAI,eAAe,OAAOD,kBAA1B,EAA8C;AAC5CG,YAAQ,GAAGH,kBAAX;AACAE,WAAO,GAAG,EAAV;AACD,GAPmB,CAQpB;;;AACA,QAAME,IAAI,GAAGF,OAAO,CAACE,IAAR,IAAgB,IAAhB,GAAuB,KAAvB,GAA+BF,OAAO,CAACE,IAApD,CAToB,CAWpB;;AACA,MAAI,yBAAYN,EAAZ,EAAgBO,WAAhB,EAAJ,EAAmC,OAAOF,QAAQ,CAAC,IAAIG,gCAAJ,EAAD,CAAf,CAZf,CAapB;;AACA,WAASC,cAAT,CAAwBC,OAAxB,EAAoC;AAClC;AACA,UAAMC,IAAI,GAAQ,EAAlB,CAFkC,CAGlC;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAACG,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,YAAME,KAAK,GAAGJ,OAAO,CAACE,CAAD,CAArB,CADuC,CAEvC;;AACAD,UAAI,CAACG,KAAK,CAACb,IAAP,CAAJ,GAAmB,EAAnB;;AACA,WAAK,MAAMA,IAAX,IAAmBa,KAAK,CAACC,GAAzB,EAA8B;AAC5BJ,YAAI,CAACG,KAAK,CAACb,IAAP,CAAJ,CAAiBe,IAAjB,CAAsB,CAACf,IAAD,EAAOa,KAAK,CAACC,GAAN,CAAUd,IAAV,CAAP,CAAtB;AACD;AACF;;AAED,WAAOU,IAAP;AACD,GA5BmB,CA8BpB;;;AACAX,IAAE,CAACiB,UAAH,CAAchB,IAAd,EACGiB,WADH,CACed,OADf,EAEGe,OAFH,CAEW,CAACC,GAAD,EAAMV,OAAN,KAAiB;AACxB,QAAIU,GAAJ,EAAS,OAAOf,QAAQ,CAACe,GAAD,CAAf;AACT,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcZ,OAAd,CAAL,EAA6B,OAAOL,QAAQ,CAACkB,SAAD,EAAY,EAAZ,CAAf;AAC7B,QAAIjB,IAAJ,EAAU,OAAOD,QAAQ,CAACkB,SAAD,EAAYb,OAAZ,CAAf;AACVL,YAAQ,CAACkB,SAAD,EAAYd,cAAc,CAACC,OAAD,CAA1B,CAAR;AACD,GAPH;AAQD;;AA3CDc;;AA6CA,SAAgBC,WAAhB,CACEC,IADF,EAEEC,IAFF,EAGEvB,OAHF,EAG4C;;;AAE1C,QAAMwB,mBAAmB,GACvB,OAAOxB,OAAO,CAACwB,mBAAf,KAAuC,SAAvC,GACIxB,OAAO,CAACwB,mBADZ,GAEI,UAAI,CAACC,CAAL,CAAO7B,EAAP,CAAUI,OAAV,MAAiB,IAAjB,IAAiB0B,aAAjB,GAAiB,MAAjB,GAAiBA,GAAEF,mBAHzB,CAF0C,CAO1C;;AACA,MAAIA,mBAAmB,KAAK,IAA5B,EAAkC;AAChC,WAAOD,IAAP;AACD;;AAED,SAAOA,IAAI,CAACI,GAAL,CAASC,GAAG,IAAG;AACpB,QAAIA,GAAG,CAACC,GAAJ,IAAW,IAAf,EAAqB;AACnBD,SAAG,CAACC,GAAJ,GAAUP,IAAI,CAACG,CAAL,CAAOK,SAAP,CAAiBC,QAAjB,EAAV;AACD;;AAED,WAAOH,GAAP;AACD,GANM,CAAP;AAOD;;AAtBDR","names":["indexInformation","db","name","_optionsOrCallback","_callback","options","callback","full","isDestroyed","error_1","processResults","indexes","info","i","length","index","key","push","collection","listIndexes","toArray","err","Array","isArray","undefined","exports","prepareDocs","coll","docs","forceServerObjectId","s","_a","map","doc","_id","pkFactory","createPk"],"sources":["/Users/santiago/Documents/tulipan1637/iot-sensor/node_modules/mongodb/src/operations/common_functions.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Collection } from '../collection';\nimport type { Db } from '../db';\nimport { MongoTopologyClosedError } from '../error';\nimport type { ReadPreference } from '../read_preference';\nimport type { ClientSession } from '../sessions';\nimport { Callback, getTopology } from '../utils';\n\n/** @public */\nexport interface IndexInformationOptions {\n  full?: boolean;\n  readPreference?: ReadPreference;\n  session?: ClientSession;\n}\n/**\n * Retrieves this collections index info.\n *\n * @param db - The Db instance on which to retrieve the index info.\n * @param name - The name of the collection.\n */\nexport function indexInformation(db: Db, name: string, callback: Callback): void;\nexport function indexInformation(\n  db: Db,\n  name: string,\n  options: IndexInformationOptions,\n  callback?: Callback\n): void;\nexport function indexInformation(\n  db: Db,\n  name: string,\n  _optionsOrCallback: IndexInformationOptions | Callback,\n  _callback?: Callback\n): void {\n  let options = _optionsOrCallback as IndexInformationOptions;\n  let callback = _callback as Callback;\n  if ('function' === typeof _optionsOrCallback) {\n    callback = _optionsOrCallback as Callback;\n    options = {};\n  }\n  // If we specified full information\n  const full = options.full == null ? false : options.full;\n\n  // Did the user destroy the topology\n  if (getTopology(db).isDestroyed()) return callback(new MongoTopologyClosedError());\n  // Process all the results from the index command and collection\n  function processResults(indexes: any) {\n    // Contains all the information\n    const info: any = {};\n    // Process all the indexes\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i];\n      // Let's unpack the object\n      info[index.name] = [];\n      for (const name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  }\n\n  // Get the list of indexes of the specified collection\n  db.collection(name)\n    .listIndexes(options)\n    .toArray((err, indexes) => {\n      if (err) return callback(err);\n      if (!Array.isArray(indexes)) return callback(undefined, []);\n      if (full) return callback(undefined, indexes);\n      callback(undefined, processResults(indexes));\n    });\n}\n\nexport function prepareDocs(\n  coll: Collection,\n  docs: Document[],\n  options: { forceServerObjectId?: boolean }\n): Document[] {\n  const forceServerObjectId =\n    typeof options.forceServerObjectId === 'boolean'\n      ? options.forceServerObjectId\n      : coll.s.db.options?.forceServerObjectId;\n\n  // no need to modify the docs if server sets the ObjectId\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n}\n"]},"metadata":{},"sourceType":"script"}