{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\n\nconst bson_1 = require(\"../bson\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\n\nconst commands_1 = require(\"./commands\");\n\nconst message_stream_1 = require(\"./message_stream\");\n\nconst stream_description_1 = require(\"./stream_description\");\n\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\n\n\nconst kStream = Symbol('stream');\n/** @internal */\n\nconst kQueue = Symbol('queue');\n/** @internal */\n\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\n\nconst kGeneration = Symbol('generation');\n/** @internal */\n\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\n\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\n\nconst kDescription = Symbol('description');\n/** @internal */\n\nconst kHello = Symbol('hello');\n/** @internal */\n\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\n\nconst kFullResult = Symbol('fullResult');\n/** @internal */\n\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    var _a, _b;\n\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = (0, utils_1.now)(); // setup parser stream and message handling\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({ ...options,\n      maxBsonMessageSize: (_b = this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    });\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    this[kMessageStream].on('error', error => this.handleIssue({\n      destroy: error\n    }));\n    stream.on('close', () => this.handleIssue({\n      isClose: true\n    }));\n    stream.on('timeout', () => this.handleIssue({\n      isTimeout: true,\n      destroy: true\n    })); // hook the message stream up to the passed in stream\n\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get hello() {\n    return this[kHello];\n  } // the `connect` method stores the result of the handshake hello on the connection\n\n\n  set hello(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kHello] = response;\n  }\n\n  get serviceId() {\n    var _a;\n\n    return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;\n  }\n\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = (0, utils_1.now)();\n  }\n\n  handleIssue(issue) {\n    if (this.closed) {\n      return;\n    }\n\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n\n    this.closed = true;\n\n    for (const [, op] of this[kQueue]) {\n      if (issue.isTimeout) {\n        op.cb(new error_1.MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n          beforeHandshake: this.hello == null\n        }));\n      } else if (issue.isClose) {\n        op.cb(new error_1.MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        force: false\n      };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n  /** @internal */\n\n\n  command(ns, cmd, options, callback) {\n    if (!(ns instanceof utils_1.MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n\n    const readPreference = (0, shared_1.getReadPreference)(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = (0, sessions_1.applySession)(session, finalCmd, options);\n\n      if (err) {\n        return callback(err);\n      }\n    } // if we have a known cluster time, gossip it\n\n\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions = Object.assign({\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n  /** @internal */\n\n\n  query(ns, cmd, options, callback) {\n    var _a;\n\n    const isExplain = cmd.$explain != null;\n    const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n\n    if (limit && (limit < 0 || limit !== 0 && limit < batchSize || limit > 0 && batchSize === 0)) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n\n    const queryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      secondaryOk: readPreference.secondaryOk()\n    };\n\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n\n    const query = new commands_1.Query(ns.toString(), cmd, queryOptions);\n\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n\n    write(this, query, {\n      [kFullResult]: true,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options)\n    }, (err, result) => {\n      if (err || !result) return callback(err, result);\n\n      if (isExplain && result.documents && result.documents[0]) {\n        return callback(undefined, result.documents[0]);\n      }\n\n      callback(undefined, result);\n    });\n  }\n  /** @internal */\n\n\n  getMore(ns, cursorId, options, callback) {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = (0, utils_1.maxWireVersion)(this);\n\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, {\n        numberToReturn: options.batchSize\n      });\n      const queryOptions = (0, shared_1.applyCommonQueryOptions)({}, Object.assign(options, { ...(0, bson_1.pluckBSONSerializeOptions)(options)\n      }));\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, {\n          cursor: {\n            id: response.cursorId,\n            nextBatch: response.documents\n          }\n        });\n      });\n      return;\n    }\n\n    const getMoreCmd = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n\n    const commandOptions = Object.assign({\n      returnFieldSelector: null,\n      documentsReturnedIn: 'nextBatch'\n    }, options);\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n  /** @internal */\n\n\n  killCursors(ns, cursorIds, options, callback) {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n\n    if ((0, utils_1.maxWireVersion)(this) < 4) {\n      try {\n        write(this, new commands_1.KillCursor(ns.toString(), cursorIds), {\n          noResponse: true,\n          ...options\n        }, callback);\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(ns, {\n      killCursors: ns.collection,\n      cursors: cursorIds\n    }, {\n      [kFullResult]: true,\n      ...options\n    }, (err, response) => {\n      if (err || !response) return callback(err);\n\n      if (response.cursorNotFound) {\n        return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n      }\n\n      if (!Array.isArray(response.documents) || response.documents.length === 0) {\n        return callback( // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n      }\n\n      callback(undefined, response.documents[0]);\n    });\n  }\n\n}\n\nexports.Connection = Connection;\n/** @event */\n\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\n\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\n\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\n\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\n\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\n\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\n\nConnection.PINNED = constants_1.PINNED;\n/** @event */\n\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\n\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n\n\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n\n}\n\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\n\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nexports.hasSessionSupport = hasSessionSupport;\n\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    const operationDescription = conn[kQueue].get(message.responseTo);\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    conn[kQueue].delete(message.responseTo);\n\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        (0, sessions_1.updateSessionFromResponse)(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  };\n}\n\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return (0, utils_1.uuidV4)().toString('hex');\n}\n\nfunction write(conn, command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options !== null && options !== void 0 ? options : {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAWA;;AAUA;;AACA;;AACA;;AACA;;AAYA;;AAKA;;AAWA;;AACA;;AACA;AAEA;;;AACA,MAAMA,OAAO,GAAGC,MAAM,CAAC,QAAD,CAAtB;AACA;;AACA,MAAMC,MAAM,GAAGD,MAAM,CAAC,OAAD,CAArB;AACA;;AACA,MAAME,cAAc,GAAGF,MAAM,CAAC,eAAD,CAA7B;AACA;;AACA,MAAMG,WAAW,GAAGH,MAAM,CAAC,YAAD,CAA1B;AACA;;AACA,MAAMI,YAAY,GAAGJ,MAAM,CAAC,aAAD,CAA3B;AACA;;AACA,MAAMK,YAAY,GAAGL,MAAM,CAAC,aAAD,CAA3B;AACA;;AACA,MAAMM,YAAY,GAAGN,MAAM,CAAC,aAAD,CAA3B;AACA;;AACA,MAAMO,MAAM,GAAGP,MAAM,CAAC,OAAD,CAArB;AACA;;AACA,MAAMQ,cAAc,GAAGR,MAAM,CAAC,eAAD,CAA7B;AACA;;AACA,MAAMS,WAAW,GAAGT,MAAM,CAAC,YAAD,CAA1B;AAuGA;;AACA,MAAaU,UAAb,SAAgCC,+BAAhC,CAAmE;AA4CjEC,cAAYC,MAAZ,EAA4BC,OAA5B,EAAsD;;;AACpD;AACA,SAAKC,EAAL,GAAUD,OAAO,CAACC,EAAlB;AACA,SAAKC,OAAL,GAAeC,gBAAgB,CAACJ,MAAD,EAASC,OAAT,CAA/B;AACA,SAAKI,eAAL,GAAuB,aAAO,CAACA,eAAR,MAAuB,IAAvB,IAAuBC,aAAvB,GAAuBA,EAAvB,GAA2B,CAAlD;AACA,SAAKC,eAAL,GAAuBN,OAAO,CAACM,eAA/B;AACA,SAAKC,SAAL,GAAiBP,OAAO,CAACO,SAAzB;AACA,SAAKC,MAAL,GAAc,KAAd;AACA,SAAKC,SAAL,GAAiB,KAAjB;AAEA,SAAKjB,YAAL,IAAqB,IAAIkB,sCAAJ,CAAsB,KAAKR,OAA3B,EAAoCF,OAApC,CAArB;AACA,SAAKX,WAAL,IAAoBW,OAAO,CAACW,UAA5B;AACA,SAAKrB,YAAL,IAAqB,kBAArB,CAZoD,CAcpD;;AACA,SAAKH,MAAL,IAAe,IAAIyB,GAAJ,EAAf;AACA,SAAKxB,cAAL,IAAuB,IAAIyB,8BAAJ,CAAkB,EACvC,GAAGb,OADoC;AAEvCc,wBAAkB,EAAE,WAAKC,KAAL,MAAU,IAAV,IAAUC,aAAV,GAAU,MAAV,GAAUA,GAAEF;AAFO,KAAlB,CAAvB;AAIA,SAAK1B,cAAL,EAAqB6B,EAArB,CAAwB,SAAxB,EAAmCC,cAAc,CAAC,IAAD,CAAjD;AACA,SAAKjC,OAAL,IAAgBc,MAAhB;AACAA,UAAM,CAACkB,EAAP,CAAU,OAAV,EAAmB,MAAK;AACtB;AACD,KAFD;AAIA,SAAK7B,cAAL,EAAqB6B,EAArB,CAAwB,OAAxB,EAAiCE,KAAK,IAAI,KAAKC,WAAL,CAAiB;AAAEC,aAAO,EAAEF;AAAX,KAAjB,CAA1C;AACApB,UAAM,CAACkB,EAAP,CAAU,OAAV,EAAmB,MAAM,KAAKG,WAAL,CAAiB;AAAEE,aAAO,EAAE;AAAX,KAAjB,CAAzB;AACAvB,UAAM,CAACkB,EAAP,CAAU,SAAV,EAAqB,MAAM,KAAKG,WAAL,CAAiB;AAAEG,eAAS,EAAE,IAAb;AAAmBF,aAAO,EAAE;AAA5B,KAAjB,CAA3B,EA5BoD,CA8BpD;;AACAtB,UAAM,CAACyB,IAAP,CAAY,KAAKpC,cAAL,CAAZ;AACA,SAAKA,cAAL,EAAqBoC,IAArB,CAA0BzB,MAA1B;AACD;;AAEc,MAAX0B,WAAW;AACb,WAAO,KAAKjC,YAAL,CAAP;AACD;;AAEQ,MAALuB,KAAK;AACP,WAAO,KAAKtB,MAAL,CAAP;AACD,GArFgE,CAuFjE;;;AACS,MAALsB,KAAK,CAACW,QAAD,EAAmB;AAC1B,SAAKlC,YAAL,EAAmBmC,eAAnB,CAAmCD,QAAnC;AACA,SAAKlC,YAAL,IAAqBoC,MAAM,CAACC,MAAP,CAAc,KAAKrC,YAAL,CAAd,CAArB,CAF0B,CAI1B;;AACA,SAAKC,MAAL,IAAeiC,QAAf;AACD;;AAEY,MAATI,SAAS;;;AACX,WAAO,WAAKf,KAAL,MAAU,IAAV,IAAUV,aAAV,GAAU,MAAV,GAAUA,GAAEyB,SAAnB;AACD;;AAEe,MAAZC,YAAY;AACd,WAAO,KAAKN,WAAL,CAAiBM,YAAxB;AACD;;AAEa,MAAVpB,UAAU;AACZ,WAAO,KAAKtB,WAAL,KAAqB,CAA5B;AACD;;AAEa,MAAVsB,UAAU,CAACA,UAAD,EAAmB;AAC/B,SAAKtB,WAAL,IAAoBsB,UAApB;AACD;;AAEW,MAARqB,QAAQ;AACV,WAAO,mCAAsB,KAAK1C,YAAL,CAAtB,CAAP;AACD;;AAEc,MAAX2C,WAAW;AACb,WAAO,KAAK1C,YAAL,CAAP;AACD;;AAES,MAANQ,MAAM;AACR,WAAO,KAAKd,OAAL,CAAP;AACD;;AAEDiD,eAAa;AACX,SAAK5C,YAAL,IAAqB,kBAArB;AACD;;AAED8B,aAAW,CAACe,KAAD,EAA6E;AACtF,QAAI,KAAK3B,MAAT,EAAiB;AACf;AACD;;AAED,QAAI2B,KAAK,CAACd,OAAV,EAAmB;AACjB,WAAKpC,OAAL,EAAcoC,OAAd,CAAsB,OAAOc,KAAK,CAACd,OAAb,KAAyB,SAAzB,GAAqCe,SAArC,GAAiDD,KAAK,CAACd,OAA7E;AACD;;AAED,SAAKb,MAAL,GAAc,IAAd;;AAEA,SAAK,MAAM,GAAG6B,EAAH,CAAX,IAAqB,KAAKlD,MAAL,CAArB,EAAmC;AACjC,UAAIgD,KAAK,CAACZ,SAAV,EAAqB;AACnBc,UAAE,CAACC,EAAH,CACE,IAAIC,gCAAJ,CAA6B,cAAc,KAAKtC,EAAE,OAAO,KAAKC,OAAO,YAArE,EAAmF;AACjFsC,yBAAe,EAAE,KAAKzB,KAAL,IAAc;AADkD,SAAnF,CADF;AAKD,OAND,MAMO,IAAIoB,KAAK,CAACb,OAAV,EAAmB;AACxBe,UAAE,CAACC,EAAH,CAAM,IAAIC,yBAAJ,CAAsB,cAAc,KAAKtC,EAAE,OAAO,KAAKC,OAAO,SAA9D,CAAN;AACD,OAFM,MAEA;AACLmC,UAAE,CAACC,EAAH,CAAM,OAAOH,KAAK,CAACd,OAAb,KAAyB,SAAzB,GAAqCe,SAArC,GAAiDD,KAAK,CAACd,OAA7D;AACD;AACF;;AAED,SAAKlC,MAAL,EAAasD,KAAb;AACA,SAAKC,IAAL,CAAU9C,UAAU,CAAC+C,KAArB;AACD;;AAMDtB,SAAO,CAACrB,OAAD,EAAsC4C,QAAtC,EAAyD;AAC9D,QAAI,OAAO5C,OAAP,KAAmB,UAAvB,EAAmC;AACjC4C,cAAQ,GAAG5C,OAAX;AACAA,aAAO,GAAG;AAAE6C,aAAK,EAAE;AAAT,OAAV;AACD;;AAED,SAAKC,kBAAL,CAAwBlD,UAAU,CAACmD,MAAnC;AACA,SAAKD,kBAAL,CAAwBlD,UAAU,CAACoD,QAAnC;AAEAhD,WAAO,GAAG4B,MAAM,CAACqB,MAAP,CAAc;AAAEJ,WAAK,EAAE;AAAT,KAAd,EAAgC7C,OAAhC,CAAV;;AACA,QAAI,KAAKf,OAAL,KAAiB,IAAjB,IAAyB,KAAKwB,SAAlC,EAA6C;AAC3C,WAAKA,SAAL,GAAiB,IAAjB;;AACA,UAAI,OAAOmC,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,gBAAQ;AACT;;AAED;AACD;;AAED,QAAI5C,OAAO,CAAC6C,KAAZ,EAAmB;AACjB,WAAK5D,OAAL,EAAcoC,OAAd;AACA,WAAKZ,SAAL,GAAiB,IAAjB;;AACA,UAAI,OAAOmC,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,gBAAQ;AACT;;AAED;AACD;;AAED,SAAK3D,OAAL,EAAciE,GAAd,CAAkB,MAAK;AACrB,WAAKzC,SAAL,GAAiB,IAAjB;;AACA,UAAI,OAAOmC,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,gBAAQ;AACT;AACF,KALD;AAMD;AAED;;;AACAO,SAAO,CACLC,EADK,EAELC,GAFK,EAGLrD,OAHK,EAIL4C,QAJK,EAIa;AAElB,QAAI,EAAEQ,EAAE,YAAYE,wBAAhB,CAAJ,EAAuC;AACrC;AACA,YAAM,IAAIf,yBAAJ,CAAsB,0CAAtB,CAAN;AACD;;AAED,UAAMgB,cAAc,GAAG,gCAAkBF,GAAlB,EAAuBrD,OAAvB,CAAvB;AACA,UAAMwD,cAAc,GAAGC,aAAa,CAAC,IAAD,CAApC;AACA,UAAMC,OAAO,GAAG1D,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAE0D,OAAzB;AAEA,QAAIzB,WAAW,GAAG,KAAKA,WAAvB;AACA,QAAI0B,QAAQ,GAAG/B,MAAM,CAACqB,MAAP,CAAc,EAAd,EAAkBI,GAAlB,CAAf;;AAEA,QAAI,KAAK9C,SAAT,EAAoB;AAClB,YAAM;AAAEqD,eAAF;AAAWC,cAAX;AAAmBC;AAAnB,UAAyC,KAAKvD,SAApD;AACAoD,cAAQ,CAACI,UAAT,GAAsBH,OAAtB;AACA,UAAIC,MAAM,IAAI,IAAd,EAAoBF,QAAQ,CAACK,SAAT,GAAqBH,MAArB;AACpB,UAAIC,iBAAiB,IAAI,IAAzB,EAA+BH,QAAQ,CAACM,oBAAT,GAAgCH,iBAAhC;AAChC;;AAED,QAAII,iBAAiB,CAAC,IAAD,CAAjB,IAA2BR,OAA/B,EAAwC;AACtC,UACEA,OAAO,CAACzB,WAAR,IACAA,WADA,IAEAyB,OAAO,CAACzB,WAAR,CAAoBA,WAApB,CAAgCkC,WAAhC,CAA4ClC,WAAW,CAACA,WAAxD,CAHF,EAIE;AACAA,mBAAW,GAAGyB,OAAO,CAACzB,WAAtB;AACD;;AAED,YAAMmC,GAAG,GAAG,6BAAaV,OAAb,EAAsBC,QAAtB,EAAgC3D,OAAhC,CAAZ;;AACA,UAAIoE,GAAJ,EAAS;AACP,eAAOxB,QAAQ,CAACwB,GAAD,CAAf;AACD;AACF,KAlCiB,CAoClB;;;AACA,QAAInC,WAAJ,EAAiB;AACf0B,cAAQ,CAACU,YAAT,GAAwBpC,WAAxB;AACD;;AAED,QAAI,wBAAU,IAAV,KAAmB,CAACuB,cAApB,IAAsCD,cAAtC,IAAwDA,cAAc,CAACe,IAAf,KAAwB,SAApF,EAA+F;AAC7FX,cAAQ,GAAG;AACTY,cAAM,EAAEZ,QADC;AAETa,uBAAe,EAAEjB,cAAc,CAACkB,MAAf;AAFR,OAAX;AAID;;AAED,UAAMC,cAAc,GAAa9C,MAAM,CAACqB,MAAP,CAC/B;AACEE,aAAO,EAAE,IADX;AAEEwB,kBAAY,EAAE,CAFhB;AAGEC,oBAAc,EAAE,CAAC,CAHnB;AAIEC,eAAS,EAAE,KAJb;AAKE;AACAC,iBAAW,EAAEvB,cAAc,CAACuB,WAAf;AANf,KAD+B,EAS/B9E,OAT+B,CAAjC;AAYA,UAAM+E,KAAK,GAAG,GAAG3B,EAAE,CAAC4B,EAAE,OAAtB;AACA,UAAMC,OAAO,GAAGzB,cAAc,GAC1B,IAAI0B,cAAJ,CAAQH,KAAR,EAAepB,QAAf,EAAyBe,cAAzB,CAD0B,GAE1B,IAAIQ,gBAAJ,CAAUH,KAAV,EAAiBpB,QAAjB,EAA2Be,cAA3B,CAFJ;;AAIA,QAAI;AACFS,WAAK,CAAC,IAAD,EAAOF,OAAP,EAAgBP,cAAhB,EAAgC9B,QAAhC,CAAL;AACD,KAFD,CAEE,OAAOwB,GAAP,EAAY;AACZxB,cAAQ,CAACwB,GAAD,CAAR;AACD;AACF;AAED;;;AACAgB,OAAK,CAAChC,EAAD,EAAuBC,GAAvB,EAAsCrD,OAAtC,EAA6D4C,QAA7D,EAA+E;;;AAClF,UAAMyC,SAAS,GAAGhC,GAAG,CAACiC,QAAJ,IAAgB,IAAlC;AACA,UAAM/B,cAAc,GAAG,aAAO,CAACA,cAAR,MAAsB,IAAtB,IAAsBlD,aAAtB,GAAsBA,EAAtB,GAA0BkF,iCAAeC,OAAhE;AACA,UAAMC,SAAS,GAAGzF,OAAO,CAACyF,SAAR,IAAqB,CAAvC;AACA,UAAMC,KAAK,GAAG1F,OAAO,CAAC0F,KAAtB;AACA,UAAMf,YAAY,GAAG3E,OAAO,CAAC2F,IAAR,IAAgB,CAArC;AACA,QAAIf,cAAc,GAAG,CAArB;;AACA,QACEc,KAAK,KACJA,KAAK,GAAG,CAAR,IAAcA,KAAK,KAAK,CAAV,IAAeA,KAAK,GAAGD,SAArC,IAAoDC,KAAK,GAAG,CAAR,IAAaD,SAAS,KAAK,CAD3E,CADP,EAGE;AACAb,oBAAc,GAAGc,KAAjB;AACD,KALD,MAKO;AACLd,oBAAc,GAAGa,SAAjB;AACD;;AAED,QAAIJ,SAAJ,EAAe;AACb;AACA;AACAT,oBAAc,GAAG,CAACgB,IAAI,CAACC,GAAL,CAASH,KAAK,IAAI,CAAlB,CAAlB;AACD;;AAED,UAAMI,YAAY,GAAmB;AACnCnB,kBADmC;AAEnCC,oBAFmC;AAGnCmB,gBAAU,EAAE,OAAOL,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCtD,SAHb;AAInCyC,eAAS,EAAE,KAJwB;AAKnCC,iBAAW,EAAEvB,cAAc,CAACuB,WAAf;AALsB,KAArC;;AAQA,QAAI9E,OAAO,CAACgG,UAAZ,EAAwB;AACtBF,kBAAY,CAACG,mBAAb,GAAmCjG,OAAO,CAACgG,UAA3C;AACD;;AAED,UAAMZ,KAAK,GAAG,IAAIF,gBAAJ,CAAU9B,EAAE,CAAC8C,QAAH,EAAV,EAAyB7C,GAAzB,EAA8ByC,YAA9B,CAAd;;AACA,QAAI,OAAO9F,OAAO,CAACmG,QAAf,KAA4B,SAAhC,EAA2C;AACzCf,WAAK,CAACe,QAAN,GAAiBnG,OAAO,CAACmG,QAAzB;AACD;;AAED,QAAI,OAAOnG,OAAO,CAACoG,WAAf,KAA+B,SAAnC,EAA8C;AAC5ChB,WAAK,CAACgB,WAAN,GAAoBpG,OAAO,CAACoG,WAA5B;AACD;;AAED,QAAI,OAAOpG,OAAO,CAACqG,OAAf,KAA2B,SAA/B,EAA0C;AACxCjB,WAAK,CAACkB,eAAN,GAAwB,CAACtG,OAAO,CAACqG,OAAjC;AACD,KAFD,MAEO,IAAI,OAAOrG,OAAO,CAACsG,eAAf,KAAmC,SAAvC,EAAkD;AACvDlB,WAAK,CAACkB,eAAN,GAAwBtG,OAAO,CAACsG,eAAhC;AACD;;AAED,QAAI,OAAOtG,OAAO,CAACuG,SAAf,KAA6B,SAAjC,EAA4C;AAC1CnB,WAAK,CAACmB,SAAN,GAAkBvG,OAAO,CAACuG,SAA1B;AACD;;AAED,QAAI,OAAOvG,OAAO,CAACwG,OAAf,KAA2B,SAA/B,EAA0C;AACxCpB,WAAK,CAACoB,OAAN,GAAgBxG,OAAO,CAACwG,OAAxB;AACD;;AAEDrB,SAAK,CACH,IADG,EAEHC,KAFG,EAGH;AAAE,OAACzF,WAAD,GAAe,IAAjB;AAAuB,SAAG,sCAA0BK,OAA1B;AAA1B,KAHG,EAIH,CAACoE,GAAD,EAAMqC,MAAN,KAAgB;AACd,UAAIrC,GAAG,IAAI,CAACqC,MAAZ,EAAoB,OAAO7D,QAAQ,CAACwB,GAAD,EAAMqC,MAAN,CAAf;;AACpB,UAAIpB,SAAS,IAAIoB,MAAM,CAACC,SAApB,IAAiCD,MAAM,CAACC,SAAP,CAAiB,CAAjB,CAArC,EAA0D;AACxD,eAAO9D,QAAQ,CAACR,SAAD,EAAYqE,MAAM,CAACC,SAAP,CAAiB,CAAjB,CAAZ,CAAf;AACD;;AAED9D,cAAQ,CAACR,SAAD,EAAYqE,MAAZ,CAAR;AACD,KAXE,CAAL;AAaD;AAED;;;AACAE,SAAO,CACLvD,EADK,EAELwD,QAFK,EAGL5G,OAHK,EAIL4C,QAJK,EAIuB;AAE5B,UAAMiE,UAAU,GAAG,CAAC,CAAC7G,OAAO,CAACL,WAAD,CAA5B;AACA,UAAMmH,WAAW,GAAG,4BAAe,IAAf,CAApB;;AACA,QAAI,CAACF,QAAL,EAAe;AACb;AACAhE,cAAQ,CAAC,IAAIL,yBAAJ,CAAsB,mDAAtB,CAAD,CAAR;AACA;AACD;;AAED,QAAIuE,WAAW,GAAG,CAAlB,EAAqB;AACnB,YAAMC,SAAS,GAAG,IAAI7B,kBAAJ,CAAY9B,EAAE,CAAC8C,QAAH,EAAZ,EAA2BU,QAA3B,EAAqC;AAAEhC,sBAAc,EAAE5E,OAAO,CAACyF;AAA1B,OAArC,CAAlB;AACA,YAAMK,YAAY,GAAG,sCACnB,EADmB,EAEnBlE,MAAM,CAACqB,MAAP,CAAcjD,OAAd,EAAuB,EAAE,GAAG,sCAA0BA,OAA1B;AAAL,OAAvB,CAFmB,CAArB;AAKA8F,kBAAY,CAACnG,WAAD,CAAZ,GAA4B,IAA5B;AACAmG,kBAAY,CAAC3C,OAAb,GAAuB,IAAvB;AACAgC,WAAK,CAAC,IAAD,EAAO4B,SAAP,EAAkBjB,YAAlB,EAAgC,CAAC1B,GAAD,EAAM1C,QAAN,KAAkB;AACrD,YAAImF,UAAJ,EAAgB,OAAOjE,QAAQ,CAACwB,GAAD,EAAM1C,QAAN,CAAf;AAChB,YAAI0C,GAAJ,EAAS,OAAOxB,QAAQ,CAACwB,GAAD,CAAf;AACTxB,gBAAQ,CAACR,SAAD,EAAY;AAAE4E,gBAAM,EAAE;AAAE/G,cAAE,EAAEyB,QAAQ,CAACkF,QAAf;AAAyBK,qBAAS,EAAEvF,QAAQ,CAACgF;AAA7C;AAAV,SAAZ,CAAR;AACD,OAJI,CAAL;AAMA;AACD;;AAED,UAAMQ,UAAU,GAAa;AAC3BP,aAAO,EAAEC,QADkB;AAE3BO,gBAAU,EAAE/D,EAAE,CAAC+D;AAFY,KAA7B;;AAKA,QAAI,OAAOnH,OAAO,CAACyF,SAAf,KAA6B,QAAjC,EAA2C;AACzCyB,gBAAU,CAACzB,SAAX,GAAuBG,IAAI,CAACC,GAAL,CAAS7F,OAAO,CAACyF,SAAjB,CAAvB;AACD;;AAED,QAAI,OAAOzF,OAAO,CAACoH,cAAf,KAAkC,QAAtC,EAAgD;AAC9CF,gBAAU,CAACG,SAAX,GAAuBrH,OAAO,CAACoH,cAA/B;AACD;;AAED,UAAM1C,cAAc,GAAG9C,MAAM,CAACqB,MAAP,CACrB;AACEgD,yBAAmB,EAAE,IADvB;AAEEqB,yBAAmB,EAAE;AAFvB,KADqB,EAKrBtH,OALqB,CAAvB;AAQA,SAAKmD,OAAL,CAAaC,EAAb,EAAiB8D,UAAjB,EAA6BxC,cAA7B,EAA6C9B,QAA7C;AACD;AAED;;;AACA2E,aAAW,CACTnE,EADS,EAEToE,SAFS,EAGTxH,OAHS,EAIT4C,QAJS,EAIS;AAElB,QAAI,CAAC4E,SAAD,IAAc,CAACC,KAAK,CAACC,OAAN,CAAcF,SAAd,CAAnB,EAA6C;AAC3C;AACA,YAAM,IAAIjF,yBAAJ,CAAsB,wCAAwCiF,SAAS,EAAvE,CAAN;AACD;;AAED,QAAI,4BAAe,IAAf,IAAuB,CAA3B,EAA8B;AAC5B,UAAI;AACFrC,aAAK,CACH,IADG,EAEH,IAAID,qBAAJ,CAAe9B,EAAE,CAAC8C,QAAH,EAAf,EAA8BsB,SAA9B,CAFG,EAGH;AAAEG,oBAAU,EAAE,IAAd;AAAoB,aAAG3H;AAAvB,SAHG,EAIH4C,QAJG,CAAL;AAMD,OAPD,CAOE,OAAOwB,GAAP,EAAY;AACZxB,gBAAQ,CAACwB,GAAD,CAAR;AACD;;AAED;AACD;;AAED,SAAKjB,OAAL,CACEC,EADF,EAEE;AAAEmE,iBAAW,EAAEnE,EAAE,CAAC+D,UAAlB;AAA8BS,aAAO,EAAEJ;AAAvC,KAFF,EAGE;AAAE,OAAC7H,WAAD,GAAe,IAAjB;AAAuB,SAAGK;AAA1B,KAHF,EAIE,CAACoE,GAAD,EAAM1C,QAAN,KAAkB;AAChB,UAAI0C,GAAG,IAAI,CAAC1C,QAAZ,EAAsB,OAAOkB,QAAQ,CAACwB,GAAD,CAAf;;AACtB,UAAI1C,QAAQ,CAACmG,cAAb,EAA6B;AAC3B,eAAOjF,QAAQ,CAAC,IAAIL,yBAAJ,CAAsB,4BAAtB,CAAD,EAAsD,IAAtD,CAAf;AACD;;AAED,UAAI,CAACkF,KAAK,CAACC,OAAN,CAAchG,QAAQ,CAACgF,SAAvB,CAAD,IAAsChF,QAAQ,CAACgF,SAAT,CAAmBoB,MAAnB,KAA8B,CAAxE,EAA2E;AACzE,eAAOlF,QAAQ,EACb;AACA,YAAIL,yBAAJ,CACE,qDAAqDiF,SAAS,CAAC,CAAD,CAAG,EADnE,CAFa,CAAf;AAMD;;AAED5E,cAAQ,CAACR,SAAD,EAAYV,QAAQ,CAACgF,SAAT,CAAmB,CAAnB,CAAZ,CAAR;AACD,KApBH;AAsBD;;AAtcgE;;AAAnEqB;AA2BE;;AACgBnI,6BAAkBoI,2BAAlB;AAChB;;AACgBpI,+BAAoBoI,6BAApB;AAChB;;AACgBpI,4BAAiBoI,0BAAjB;AAChB;;AACgBpI,mCAAwBoI,iCAAxB;AAChB;;AACgBpI,mBAAQoI,iBAAR;AAChB;;AACgBpI,qBAAUoI,mBAAV;AAChB;;AACgBpI,oBAASoI,kBAAT;AAChB;;AACgBpI,sBAAWoI,oBAAX;AA+ZlB;;AACA,MAAaC,gBAAb,SAAsCrI,UAAtC,CAAgD;AAI9CE,cAAYC,MAAZ,EAA4BC,OAA5B,EAAsD;AACpD,UAAMD,MAAN,EAAcC,OAAd;AACA,SAAKN,cAAL,IAAuBM,OAAO,CAACkI,aAA/B;AACD;AAED;;;AACA/E,SAAO,CAACC,EAAD,EAAuBC,GAAvB,EAAsCrD,OAAtC,EAA+D4C,QAA/D,EAAiF;AACtF,UAAMsF,aAAa,GAAG,KAAKxI,cAAL,CAAtB;;AACA,QAAI,CAACwI,aAAL,EAAoB;AAClB,aAAOtF,QAAQ,CAAC,IAAIL,mCAAJ,CAAgC,2CAAhC,CAAD,CAAf;AACD;;AAED,UAAM4F,iBAAiB,GAAG,4BAAe,IAAf,CAA1B;;AACA,QAAIA,iBAAiB,KAAK,CAA1B,EAA6B;AAC3B;AACA,aAAO,MAAMhF,OAAN,CAAcC,EAAd,EAAkBC,GAAlB,EAAuBrD,OAAvB,EAAgC4C,QAAhC,CAAP;AACD;;AAED,QAAIuF,iBAAiB,GAAG,CAAxB,EAA2B;AACzBvF,cAAQ,CACN,IAAIL,+BAAJ,CAA4B,2DAA5B,CADM,CAAR;AAGA;AACD;;AAED2F,iBAAa,CAACE,OAAd,CAAsBhF,EAAE,CAAC8C,QAAH,EAAtB,EAAqC7C,GAArC,EAA0CrD,OAA1C,EAAmD,CAACoE,GAAD,EAAMiE,SAAN,KAAmB;AACpE,UAAIjE,GAAG,IAAIiE,SAAS,IAAI,IAAxB,EAA8B;AAC5BzF,gBAAQ,CAACwB,GAAD,EAAM,IAAN,CAAR;AACA;AACD;;AAED,YAAMjB,OAAN,CAAcC,EAAd,EAAkBiF,SAAlB,EAA6BrI,OAA7B,EAAsC,CAACoE,GAAD,EAAM1C,QAAN,KAAkB;AACtD,YAAI0C,GAAG,IAAI1C,QAAQ,IAAI,IAAvB,EAA6B;AAC3BkB,kBAAQ,CAACwB,GAAD,EAAM1C,QAAN,CAAR;AACA;AACD;;AAEDwG,qBAAa,CAACI,OAAd,CAAsB5G,QAAtB,EAAgC1B,OAAhC,EAAyC4C,QAAzC;AACD,OAPD;AAQD,KAdD;AAeD;;AA5C6C;;AAAhDmF;AA+CA;;AACA,SAAgB7D,iBAAhB,CAAkCqE,IAAlC,EAAkD;AAChD,QAAM9G,WAAW,GAAG8G,IAAI,CAAC9G,WAAzB;AACA,SAAOA,WAAW,CAAC+G,4BAAZ,IAA4C,IAA5C,IAAoD,CAAC,CAAC/G,WAAW,CAACM,YAAzE;AACD;;AAHDgG;;AAKA,SAAStE,aAAT,CAAuB8E,IAAvB,EAAuC;AACrC,QAAM9G,WAAW,GAAG8G,IAAI,CAAC9G,WAAzB;;AACA,MAAIA,WAAW,IAAI,IAAnB,EAAyB;AACvB,WAAO,KAAP;AACD;;AAED,SAAO,4BAAe8G,IAAf,KAAwB,CAAxB,IAA6B,CAAC9G,WAAW,CAACgH,sBAAjD;AACD;;AAED,SAASvH,cAAT,CAAwBqH,IAAxB,EAAwC;AACtC,SAAO,SAASrH,cAAT,CAAwB+D,OAAxB,EAAkD;AACvD;AACAsD,QAAI,CAAC7F,IAAL,CAAU,SAAV,EAAqBuC,OAArB;AACA,UAAMyD,oBAAoB,GAAGH,IAAI,CAACpJ,MAAD,CAAJ,CAAawJ,GAAb,CAAiB1D,OAAO,CAAC2D,UAAzB,CAA7B;;AACA,QAAI,CAACF,oBAAL,EAA2B;AACzB;AACD;;AAED,UAAM9F,QAAQ,GAAG8F,oBAAoB,CAACpG,EAAtC,CARuD,CAUvD;AACA;AACA;;AACAiG,QAAI,CAACpJ,MAAD,CAAJ,CAAa0J,MAAb,CAAoB5D,OAAO,CAAC2D,UAA5B;;AACA,QAAI,gBAAgB3D,OAAhB,IAA2BA,OAAO,CAAC6D,UAAvC,EAAmD;AACjD;AACAP,UAAI,CAACpJ,MAAD,CAAJ,CAAa4J,GAAb,CAAiB9D,OAAO,CAAC+D,SAAzB,EAAoCN,oBAApC;AACD,KAHD,MAGO,IAAIA,oBAAoB,CAACO,qBAAzB,EAAgD;AACrDV,UAAI,CAACtJ,OAAD,CAAJ,CAAciK,UAAd,CAAyBX,IAAI,CAACnI,eAA9B;AACD;;AAED,QAAI;AACF;AACA6E,aAAO,CAACkE,KAAR,CAAcT,oBAAd;AACD,KAHD,CAGE,OAAOtE,GAAP,EAAY;AACZ;AACA;AACA;AACAxB,cAAQ,CAACwB,GAAD,CAAR;AACA;AACD;;AAED,QAAIa,OAAO,CAACyB,SAAR,CAAkB,CAAlB,CAAJ,EAA0B;AACxB,YAAM0C,QAAQ,GAAanE,OAAO,CAACyB,SAAR,CAAkB,CAAlB,CAA3B;AACA,YAAMhD,OAAO,GAAGgF,oBAAoB,CAAChF,OAArC;;AACA,UAAIA,OAAJ,EAAa;AACX,kDAA0BA,OAA1B,EAAmC0F,QAAnC;AACD;;AAED,UAAIA,QAAQ,CAAC/E,YAAb,EAA2B;AACzBkE,YAAI,CAAChJ,YAAD,CAAJ,GAAqB6J,QAAQ,CAAC/E,YAA9B;AACAkE,YAAI,CAAC7F,IAAL,CAAU9C,UAAU,CAACyJ,qBAArB,EAA4CD,QAAQ,CAAC/E,YAArD;AACD;;AAED,UAAIqE,oBAAoB,CAACvF,OAAzB,EAAkC;AAChC,YAAIiG,QAAQ,CAACE,iBAAb,EAAgC;AAC9B1G,kBAAQ,CAAC,IAAIL,8BAAJ,CAA2B6G,QAAQ,CAACE,iBAApC,EAAuDF,QAAvD,CAAD,CAAR;AACA;AACD;;AAED,YAAIA,QAAQ,CAACG,EAAT,KAAgB,CAAhB,IAAqBH,QAAQ,CAACI,IAA9B,IAAsCJ,QAAQ,CAACK,MAA/C,IAAyDL,QAAQ,CAACM,IAAtE,EAA4E;AAC1E9G,kBAAQ,CAAC,IAAIL,wBAAJ,CAAqB6G,QAArB,CAAD,CAAR;AACA;AACD;AACF,OAVD,MAUO;AACL;AACA,YAAIA,QAAQ,CAACG,EAAT,KAAgB,CAAhB,IAAqBH,QAAQ,CAACI,IAA9B,IAAsCJ,QAAQ,CAACK,MAAnD,EAA2D;AACzD7G,kBAAQ,CAAC,IAAIL,wBAAJ,CAAqB6G,QAArB,CAAD,CAAR;AACA;AACD;AACF;AACF;;AAEDxG,YAAQ,CAACR,SAAD,EAAYsG,oBAAoB,CAAC7B,UAArB,GAAkC5B,OAAlC,GAA4CA,OAAO,CAACyB,SAAR,CAAkB,CAAlB,CAAxD,CAAR;AACD,GAhED;AAiED;;AAED,SAASvG,gBAAT,CAA0BJ,MAA1B,EAA0CC,OAA1C,EAAoE;AAClE,MAAIA,OAAO,CAAC2J,SAAZ,EAAuB;AACrB;AACA;AACA,WAAO3J,OAAO,CAAC4J,WAAR,CAAoB1D,QAApB,EAAP;AACD;;AAED,MAAI,OAAOnG,MAAM,CAACG,OAAd,KAA0B,UAA9B,EAA0C;AACxC,WAAO,GAAGH,MAAM,CAAC8J,aAAa,IAAI9J,MAAM,CAAC+J,UAAU,EAAnD;AACD;;AAED,SAAO,sBAAS5D,QAAT,CAAkB,KAAlB,CAAP;AACD;;AAED,SAASf,KAAT,CACEoD,IADF,EAEEpF,OAFF,EAGEnD,OAHF,EAIE4C,QAJF,EAIoB;AAElB,MAAI,OAAO5C,OAAP,KAAmB,UAAvB,EAAmC;AACjC4C,YAAQ,GAAG5C,OAAX;AACD;;AAEDA,SAAO,GAAGA,OAAO,SAAP,WAAO,WAAP,aAAW,EAArB;AACA,QAAM0I,oBAAoB,GAAyB;AACjDM,aAAS,EAAE7F,OAAO,CAAC6F,SAD8B;AAEjD1G,MAAE,EAAEM,QAF6C;AAGjDc,WAAO,EAAE1D,OAAO,CAAC0D,OAHgC;AAIjDmD,cAAU,EAAE,CAAC,CAAC7G,OAAO,CAACL,WAAD,CAJ4B;AAKjDgI,cAAU,EAAE,OAAO3H,OAAO,CAAC2H,UAAf,KAA8B,SAA9B,GAA0C3H,OAAO,CAAC2H,UAAlD,GAA+D,KAL1B;AAMjDL,uBAAmB,EAAEtH,OAAO,CAACsH,mBANoB;AAOjDnE,WAAO,EAAE,CAAC,CAACnD,OAAO,CAACmD,OAP8B;AASjD;AACA4G,gBAAY,EAAE,OAAO/J,OAAO,CAAC+J,YAAf,KAAgC,SAAhC,GAA4C/J,OAAO,CAAC+J,YAApD,GAAmE,IAVhC;AAWjDC,iBAAa,EAAE,OAAOhK,OAAO,CAACgK,aAAf,KAAiC,SAAjC,GAA6ChK,OAAO,CAACgK,aAArD,GAAqE,IAXnC;AAYjDC,kBAAc,EAAE,OAAOjK,OAAO,CAACiK,cAAf,KAAkC,SAAlC,GAA8CjK,OAAO,CAACiK,cAAtD,GAAuE,KAZtC;AAajDC,cAAU,EAAE,OAAOlK,OAAO,CAACkK,UAAf,KAA8B,SAA9B,GAA0ClK,OAAO,CAACkK,UAAlD,GAA+D,KAb1B;AAcjDC,wBAAoB,EAClB,OAAOnK,OAAO,CAACmK,oBAAf,KAAwC,SAAxC,GAAoDnK,OAAO,CAACmK,oBAA5D,GAAmF,IAfpC;AAgBjDC,OAAG,EAAE,OAAOpK,OAAO,CAACoK,GAAf,KAAuB,SAAvB,GAAmCpK,OAAO,CAACoK,GAA3C,GAAiD,KAhBL;AAiBjDC,WAAO,EAAE;AAjBwC,GAAnD;;AAoBA,MAAI9B,IAAI,CAAC/I,YAAD,CAAJ,IAAsB+I,IAAI,CAAC/I,YAAD,CAAJ,CAAmB8K,UAA7C,EAAyD;AACvD5B,wBAAoB,CAAC6B,gBAArB,GAAwChC,IAAI,CAAC/I,YAAD,CAAJ,CAAmB8K,UAA3D;;AAEA,QAAI/B,IAAI,CAAC/I,YAAD,CAAJ,CAAmBgL,oBAAvB,EAA6C;AAC3C9B,0BAAoB,CAAC8B,oBAArB,GAA4CjC,IAAI,CAAC/I,YAAD,CAAJ,CAAmBgL,oBAA/D;AACD;AACF;;AAED,MAAI,OAAOxK,OAAO,CAACI,eAAf,KAAmC,QAAvC,EAAiD;AAC/CsI,wBAAoB,CAACO,qBAArB,GAA6C,IAA7C;AACAV,QAAI,CAACtJ,OAAD,CAAJ,CAAciK,UAAd,CAAyBlJ,OAAO,CAACI,eAAjC;AACD,GAtCiB,CAwClB;;;AACA,MAAImI,IAAI,CAACjI,eAAT,EAA0B;AACxBiI,QAAI,CAAC7F,IAAL,CAAU9C,UAAU,CAAC6K,eAArB,EAAsC,IAAIC,+CAAJ,CAAwBnC,IAAxB,EAA8BpF,OAA9B,CAAtC;AAEAuF,wBAAoB,CAAC2B,OAArB,GAA+B,kBAA/B;;AACA3B,wBAAoB,CAACpG,EAArB,GAA0B,CAAC8B,GAAD,EAAMuG,KAAN,KAAe;AACvC,UAAIvG,GAAJ,EAAS;AACPmE,YAAI,CAAC7F,IAAL,CACE9C,UAAU,CAACgL,cADb,EAEE,IAAIF,8CAAJ,CAAuBnC,IAAvB,EAA6BpF,OAA7B,EAAsCiB,GAAtC,EAA2CsE,oBAAoB,CAAC2B,OAAhE,CAFF;AAID,OALD,MAKO;AACL,YAAIM,KAAK,KAAKA,KAAK,CAACpB,EAAN,KAAa,CAAb,IAAkBoB,KAAK,CAACnB,IAA7B,CAAT,EAA6C;AAC3CjB,cAAI,CAAC7F,IAAL,CACE9C,UAAU,CAACgL,cADb,EAEE,IAAIF,8CAAJ,CAAuBnC,IAAvB,EAA6BpF,OAA7B,EAAsCwH,KAAtC,EAA6CjC,oBAAoB,CAAC2B,OAAlE,CAFF;AAID,SALD,MAKO;AACL9B,cAAI,CAAC7F,IAAL,CACE9C,UAAU,CAACiL,iBADb,EAEE,IAAIH,iDAAJ,CAA0BnC,IAA1B,EAAgCpF,OAAhC,EAAyCwH,KAAzC,EAAgDjC,oBAAoB,CAAC2B,OAArE,CAFF;AAID;AACF;;AAED,UAAI,OAAOzH,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,gBAAQ,CAACwB,GAAD,EAAMuG,KAAN,CAAR;AACD;AACF,KAvBD;AAwBD;;AAED,MAAI,CAACjC,oBAAoB,CAACf,UAA1B,EAAsC;AACpCY,QAAI,CAACpJ,MAAD,CAAJ,CAAa4J,GAAb,CAAiBL,oBAAoB,CAACM,SAAtC,EAAiDN,oBAAjD;AACD;;AAED,MAAI;AACFH,QAAI,CAACnJ,cAAD,CAAJ,CAAqB0L,YAArB,CAAkC3H,OAAlC,EAA2CuF,oBAA3C;AACD,GAFD,CAEE,OAAOqC,CAAP,EAAU;AACV,QAAI,CAACrC,oBAAoB,CAACf,UAA1B,EAAsC;AACpCY,UAAI,CAACpJ,MAAD,CAAJ,CAAa0J,MAAb,CAAoBH,oBAAoB,CAACM,SAAzC;AACAN,0BAAoB,CAACpG,EAArB,CAAwByI,CAAxB;AACA;AACD;AACF;;AAED,MAAIrC,oBAAoB,CAACf,UAAzB,EAAqC;AACnCe,wBAAoB,CAACpG,EAArB;AACD;AACF","names":["kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kHello","kAutoEncrypter","kFullResult","Connection","mongo_types_1","constructor","stream","options","id","address","streamIdentifier","socketTimeoutMS","_a","monitorCommands","serverApi","closed","destroyed","stream_description_1","generation","Map","message_stream_1","maxBsonMessageSize","hello","_b","on","messageHandler","error","handleIssue","destroy","isClose","isTimeout","pipe","description","response","receiveResponse","Object","freeze","serviceId","loadBalanced","idleTime","clusterTime","markAvailable","issue","undefined","op","cb","error_1","beforeHandshake","clear","emit","CLOSE","callback","force","removeAllListeners","PINNED","UNPINNED","assign","end","command","ns","cmd","utils_1","readPreference","shouldUseOpMsg","supportsOpMsg","session","finalCmd","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","hasSessionSupport","greaterThan","err","$clusterTime","mode","$query","$readPreference","toJSON","commandOptions","numberToSkip","numberToReturn","checkKeys","secondaryOk","cmdNs","db","message","commands_1","write","query","isExplain","$explain","read_preference_1","primary","batchSize","limit","skip","Math","abs","queryOptions","pre32Limit","projection","returnFieldSelector","toString","tailable","oplogReplay","timeout","noCursorTimeout","awaitData","partial","result","documents","getMore","cursorId","fullResult","wireVersion","getMoreOp","cursor","nextBatch","getMoreCmd","collection","maxAwaitTimeMS","maxTimeMS","documentsReturnedIn","killCursors","cursorIds","Array","isArray","noResponse","cursors","cursorNotFound","length","exports","constants_1","CryptoConnection","autoEncrypter","serverWireVersion","encrypt","encrypted","decrypt","conn","logicalSessionTimeoutMinutes","__nodejs_mock_server__","operationDescription","get","responseTo","delete","moreToCome","set","requestId","socketTimeoutOverride","setTimeout","parse","document","CLUSTER_TIME_RECEIVED","writeConcernError","ok","$err","errmsg","code","proxyHost","hostAddress","remoteAddress","remotePort","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","enableUtf8Validation","raw","started","compressor","agreedCompressor","zlibCompressionLevel","COMMAND_STARTED","command_monitoring_events_1","reply","COMMAND_FAILED","COMMAND_SUCCEEDED","writeCommand","e"],"sources":["/Users/santiago/Documents/tulipan1637/iot-sensor/node_modules/mongodb/src/cmap/connection.ts"],"sourcesContent":["import { BSONSerializeOptions, Document, Long, ObjectId, pluckBSONSerializeOptions } from '../bson';\nimport {\n  CLOSE,\n  CLUSTER_TIME_RECEIVED,\n  COMMAND_FAILED,\n  COMMAND_STARTED,\n  COMMAND_SUCCEEDED,\n  MESSAGE,\n  PINNED,\n  UNPINNED\n} from '../constants';\nimport type { AutoEncrypter } from '../deps';\nimport {\n  MongoCompatibilityError,\n  MongoMissingDependencyError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoWriteConcernError\n} from '../error';\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\nimport { CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport { ReadPreference, ReadPreferenceLike } from '../read_preference';\nimport { applySession, ClientSession, updateSessionFromResponse } from '../sessions';\nimport {\n  calculateDurationInMs,\n  Callback,\n  ClientMetadata,\n  HostAddress,\n  maxWireVersion,\n  MongoDBNamespace,\n  now,\n  uuidV4\n} from '../utils';\nimport type { W, WriteConcern, WriteConcernOptions } from '../write_concern';\nimport type { MongoCredentials } from './auth/mongo_credentials';\nimport {\n  CommandFailedEvent,\n  CommandStartedEvent,\n  CommandSucceededEvent\n} from './command_monitoring_events';\nimport {\n  BinMsg,\n  GetMore,\n  KillCursor,\n  Msg,\n  OpQueryOptions,\n  Query,\n  Response,\n  WriteProtocolMessageType\n} from './commands';\nimport type { Stream } from './connect';\nimport { MessageStream, OperationDescription } from './message_stream';\nimport { StreamDescription, StreamDescriptionOptions } from './stream_description';\nimport { applyCommonQueryOptions, getReadPreference, isSharded } from './wire_protocol/shared';\n\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kHello = Symbol('hello');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kFullResult = Symbol('fullResult');\n\n/** @internal */\nexport interface QueryOptions extends BSONSerializeOptions {\n  readPreference: ReadPreference;\n  documentsReturnedIn?: string;\n  batchSize?: number;\n  limit?: number;\n  skip?: number;\n  projection?: Document;\n  tailable?: boolean;\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** @deprecated use `noCursorTimeout` instead */\n  timeout?: boolean;\n  partial?: boolean;\n  oplogReplay?: boolean;\n}\n\n/** @internal */\nexport interface CommandOptions extends BSONSerializeOptions {\n  command?: boolean;\n  secondaryOk?: boolean;\n  /** Specify read preference if command supports it */\n  readPreference?: ReadPreferenceLike;\n  raw?: boolean;\n  monitoring?: boolean;\n  [kFullResult]?: boolean;\n  socketTimeoutMS?: number;\n  /** Session to use for the operation */\n  session?: ClientSession;\n  documentsReturnedIn?: string;\n  noResponse?: boolean;\n  omitReadPreference?: boolean;\n\n  // FIXME: NODE-2802\n  willRetryWrite?: boolean;\n\n  // FIXME: NODE-2781\n  writeConcern?: WriteConcernOptions | WriteConcern | W;\n}\n\n/** @internal */\nexport interface GetMoreOptions extends CommandOptions {\n  batchSize?: number;\n  maxTimeMS?: number;\n  maxAwaitTimeMS?: number;\n  comment?: Document | string;\n}\n\n/** @public */\nexport interface ProxyOptions {\n  proxyHost?: string;\n  proxyPort?: number;\n  proxyUsername?: string;\n  proxyPassword?: string;\n}\n\n/** @public */\nexport interface ConnectionOptions\n  extends SupportedNodeConnectionOptions,\n    StreamDescriptionOptions,\n    ProxyOptions {\n  // Internal creation info\n  id: number | '<monitor>';\n  generation: number;\n  hostAddress: HostAddress;\n  // Settings\n  autoEncrypter?: AutoEncrypter;\n  serverApi?: ServerApi;\n  monitorCommands: boolean;\n  /** @internal */\n  connectionType?: typeof Connection;\n  credentials?: MongoCredentials;\n  connectTimeoutMS?: number;\n  tls: boolean;\n  keepAlive?: boolean;\n  keepAliveInitialDelay?: number;\n  noDelay?: boolean;\n  socketTimeoutMS?: number;\n  cancellationToken?: CancellationToken;\n\n  metadata: ClientMetadata;\n}\n\n/** @public */\nexport interface DestroyOptions {\n  /** Force the destruction. */\n  force?: boolean;\n}\n\n/** @public */\nexport type ConnectionEvents = {\n  commandStarted(event: CommandStartedEvent): void;\n  commandSucceeded(event: CommandSucceededEvent): void;\n  commandFailed(event: CommandFailedEvent): void;\n  clusterTimeReceived(clusterTime: Document): void;\n  close(): void;\n  message(message: any): void;\n  pinned(pinType: string): void;\n  unpinned(pinType: string): void;\n};\n\n/** @internal */\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\n  id: number | '<monitor>';\n  address: string;\n  socketTimeoutMS: number;\n  monitorCommands: boolean;\n  closed: boolean;\n  destroyed: boolean;\n  lastHelloMS?: number;\n  serverApi?: ServerApi;\n  helloOk?: boolean;\n  /** @internal */\n  [kDescription]: StreamDescription;\n  /** @internal */\n  [kGeneration]: number;\n  /** @internal */\n  [kLastUseTime]: number;\n  /** @internal */\n  [kQueue]: Map<number, OperationDescription>;\n  /** @internal */\n  [kMessageStream]: MessageStream;\n  /** @internal */\n  [kStream]: Stream;\n  /** @internal */\n  [kHello]: Document;\n  /** @internal */\n  [kClusterTime]: Document;\n\n  /** @event */\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\n  /** @event */\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\n  /** @event */\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\n  /** @event */\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly MESSAGE = MESSAGE;\n  /** @event */\n  static readonly PINNED = PINNED;\n  /** @event */\n  static readonly UNPINNED = UNPINNED;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream({\n      ...options,\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\n    });\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    this[kMessageStream].on('error', error => this.handleIssue({ destroy: error }));\n    stream.on('close', () => this.handleIssue({ isClose: true }));\n    stream.on('timeout', () => this.handleIssue({ isTimeout: true, destroy: true }));\n\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description(): StreamDescription {\n    return this[kDescription];\n  }\n\n  get hello(): Document {\n    return this[kHello];\n  }\n\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response: Document) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n\n  get serviceId(): ObjectId | undefined {\n    return this.hello?.serviceId;\n  }\n\n  get loadBalanced(): boolean {\n    return this.description.loadBalanced;\n  }\n\n  get generation(): number {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation: number) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime(): number {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime(): Document {\n    return this[kClusterTime];\n  }\n\n  get stream(): Stream {\n    return this[kStream];\n  }\n\n  markAvailable(): void {\n    this[kLastUseTime] = now();\n  }\n\n  handleIssue(issue: { isTimeout?: boolean; isClose?: boolean; destroy?: boolean | Error }): void {\n    if (this.closed) {\n      return;\n    }\n\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n\n    this.closed = true;\n\n    for (const [, op] of this[kQueue]) {\n      if (issue.isTimeout) {\n        op.cb(\n          new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n            beforeHandshake: this.hello == null\n          })\n        );\n      } else if (issue.isClose) {\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  destroy(): void;\n  destroy(callback: Callback): void;\n  destroy(options: DestroyOptions): void;\n  destroy(options: DestroyOptions, callback: Callback): void;\n  destroy(options?: DestroyOptions | Callback, callback?: Callback): void {\n    if (typeof options === 'function') {\n      callback = options;\n      options = { force: false };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n\n  /** @internal */\n  command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions | undefined,\n    callback: Callback\n  ): void {\n    if (!(ns instanceof MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n\n    const readPreference = getReadPreference(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options?.session;\n\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const { version, strict, deprecationErrors } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (\n        session.clusterTime &&\n        clusterTime &&\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n      ) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = applySession(session, finalCmd, options as CommandOptions);\n      if (err) {\n        return callback(err);\n      }\n    }\n\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if (isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions: Document = Object.assign(\n      {\n        command: true,\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        secondaryOk: readPreference.secondaryOk()\n      },\n      options\n    );\n\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg\n      ? new Msg(cmdNs, finalCmd, commandOptions)\n      : new Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n\n  /** @internal */\n  query(ns: MongoDBNamespace, cmd: Document, options: QueryOptions, callback: Callback): void {\n    const isExplain = cmd.$explain != null;\n    const readPreference = options.readPreference ?? ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n    if (\n      limit &&\n      (limit < 0 || (limit !== 0 && limit < batchSize) || (limit > 0 && batchSize === 0))\n    ) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n\n    const queryOptions: OpQueryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      secondaryOk: readPreference.secondaryOk()\n    };\n\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n\n    const query = new Query(ns.toString(), cmd, queryOptions);\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n\n    write(\n      this,\n      query,\n      { [kFullResult]: true, ...pluckBSONSerializeOptions(options) },\n      (err, result) => {\n        if (err || !result) return callback(err, result);\n        if (isExplain && result.documents && result.documents[0]) {\n          return callback(undefined, result.documents[0]);\n        }\n\n        callback(undefined, result);\n      }\n    );\n  }\n\n  /** @internal */\n  getMore(\n    ns: MongoDBNamespace,\n    cursorId: Long,\n    options: GetMoreOptions,\n    callback: Callback<Document>\n  ): void {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = maxWireVersion(this);\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new GetMore(ns.toString(), cursorId, { numberToReturn: options.batchSize });\n      const queryOptions = applyCommonQueryOptions(\n        {},\n        Object.assign(options, { ...pluckBSONSerializeOptions(options) })\n      );\n\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, { cursor: { id: response.cursorId, nextBatch: response.documents } });\n      });\n\n      return;\n    }\n\n    const getMoreCmd: Document = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n\n    const commandOptions = Object.assign(\n      {\n        returnFieldSelector: null,\n        documentsReturnedIn: 'nextBatch'\n      },\n      options\n    );\n\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n\n  /** @internal */\n  killCursors(\n    ns: MongoDBNamespace,\n    cursorIds: Long[],\n    options: CommandOptions,\n    callback: Callback\n  ): void {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n\n    if (maxWireVersion(this) < 4) {\n      try {\n        write(\n          this,\n          new KillCursor(ns.toString(), cursorIds),\n          { noResponse: true, ...options },\n          callback\n        );\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(\n      ns,\n      { killCursors: ns.collection, cursors: cursorIds },\n      { [kFullResult]: true, ...options },\n      (err, response) => {\n        if (err || !response) return callback(err);\n        if (response.cursorNotFound) {\n          return callback(new MongoNetworkError('cursor killed or timed out'), null);\n        }\n\n        if (!Array.isArray(response.documents) || response.documents.length === 0) {\n          return callback(\n            // TODO(NODE-3483)\n            new MongoRuntimeError(\n              `invalid killCursors result returned for cursor id ${cursorIds[0]}`\n            )\n          );\n        }\n\n        callback(undefined, response.documents[0]);\n      }\n    );\n  }\n}\n\n/** @internal */\nexport class CryptoConnection extends Connection {\n  /** @internal */\n  [kAutoEncrypter]?: AutoEncrypter;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n\n  /** @internal @override */\n  command(ns: MongoDBNamespace, cmd: Document, options: CommandOptions, callback: Callback): void {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = maxWireVersion(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(\n        new MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2')\n      );\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n}\n\n/** @internal */\nexport function hasSessionSupport(conn: Connection): boolean {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nfunction supportsOpMsg(conn: Connection) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n\n  return maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction messageHandler(conn: Connection) {\n  return function messageHandler(message: BinMsg | Response) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    conn[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document: Document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  };\n}\n\nfunction streamIdentifier(stream: Stream, options: ConnectionOptions): string {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\nfunction write(\n  conn: Connection,\n  command: WriteProtocolMessageType,\n  options: CommandOptions,\n  callback: Callback\n) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options ?? {};\n  const operationDescription: OperationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation:\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new CommandStartedEvent(conn, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(\n          Connection.COMMAND_FAILED,\n          new CommandFailedEvent(conn, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(\n            Connection.COMMAND_FAILED,\n            new CommandFailedEvent(conn, command, reply, operationDescription.started)\n          );\n        } else {\n          conn.emit(\n            Connection.COMMAND_SUCCEEDED,\n            new CommandSucceededEvent(conn, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}